(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,
  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding
  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support
  // because we need to be able to add all the node Buffer API methods. This is an issue
  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // assume that object is array-like
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function _utf16leWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = _asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = _binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = _base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = _asciiSlice(self, start, end)
      break
    case 'binary':
      ret = _binarySlice(self, start, end)
      break
    case 'base64':
      ret = _base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !Buffer._useTypedArrays) {
    for (var i = 0; i < len; i++)
      target[i + target_start] = this[i + start]
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function _utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/..\\node_modules\\gulp-browserify\\node_modules\\browserify\\node_modules\\buffer\\index.js","/..\\node_modules\\gulp-browserify\\node_modules\\browserify\\node_modules\\buffer")
},{"VCmEsw":4,"base64-js":2,"buffer":1,"ieee754":3}],2:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/..\\node_modules\\gulp-browserify\\node_modules\\browserify\\node_modules\\buffer\\node_modules\\base64-js\\lib\\b64.js","/..\\node_modules\\gulp-browserify\\node_modules\\browserify\\node_modules\\buffer\\node_modules\\base64-js\\lib")
},{"VCmEsw":4,"buffer":1}],3:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/..\\node_modules\\gulp-browserify\\node_modules\\browserify\\node_modules\\buffer\\node_modules\\ieee754\\index.js","/..\\node_modules\\gulp-browserify\\node_modules\\browserify\\node_modules\\buffer\\node_modules\\ieee754")
},{"VCmEsw":4,"buffer":1}],4:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}


process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/..\\node_modules\\gulp-browserify\\node_modules\\browserify\\node_modules\\process\\browser.js","/..\\node_modules\\gulp-browserify\\node_modules\\browserify\\node_modules\\process")
},{"VCmEsw":4,"buffer":1}],5:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){

//ADD ICON TO LINKS THAT HAS EXTERNAL LINK
$("a[target=_blank]").each(function () {   

	if ( $("a[target=_blank]").has("img").length )
	{
		$(this).removeClass("external-url");
	}
	else
	{
		 $(this).addClass('external-url');
	}    
}); 

}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/addExternaliconFunction.js","/")
},{"VCmEsw":4,"buffer":1}],6:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){

// IF COOKIE DOES NOT EXISTS, SHOW COOKIE POPUP
if($.cookie('analyticsAccepted') === undefined) {

	// SHOW COOKIE POPUP
	$('#cookies_viewer').show();

	// IF COOKIE IS ACCEPTED 
	$('#cookie_accept').click(function(e){
		e.preventDefault();
		setCookieAcceptance();
	});

	// IF COOKIE IS ACCEPTED 
	$('#cookie_cancel').click(function(e){
		e.preventDefault();
		$('#cookies_viewer').hide();
	});

	// If the user starts to click around, hide the cookie viewer and store cookie
    $("div#s4-bodyContainer a").click(function () {
        setCookieAcceptance();
    });
}
else {
	setCookieAcceptance();	
}

function setCookieAcceptance() {

	function loadSiteImprove(){
	    var sz = document.createElement('script');
	    sz.type = 'text/javascript';
	    sz.async = true;
	    sz.src = '//ssl.siteimprove.com/js/siteanalyze_260336.js';
	    var s = document.getElementsByTagName('script')[0];
	    s.parentNode.insertBefore(sz, s);
	}

	// Hide the cookie view, and store cookie
	$('#cookies_viewer').hide();
	$.cookie('analyticsAccepted', "1", {expires: 365, path: '/' });

	// Load site-improve
	loadSiteImprove();
}


}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/cookie.js","/")
},{"VCmEsw":4,"buffer":1}],7:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
﻿var clientContext;
var website;
var user;

function isInternetExplorer() {
    var ua = window.navigator.userAgent;
    var msie = ua.indexOf("MSIE ");

    if (msie > 0 || !!navigator.userAgent.match(/Trident.*rv\:11\./))
        return true;
    else
        return false;
}

function replaceDownloadLinks() {
    //var updateFileExt = new Array(".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx");
    //var checkString = "";

    //for (var i = 0; i < updateFileExt.length; i++) {
    //    checkString += 'a[href$="' + updateFileExt[i] + '"], a[href$="' + updateFileExt[i].toUpperCase() + '"], ';
    //}

    //checkString = checkString.substring(0, checkString.length - 2);

    //$(checkString).each(function () {
    //    if ((this.href.toLowerCase().indexOf("/_layouts/download.aspx?sourceurl=") > 0) === false) {
    //        var newDocUrl = "/_layouts/download.aspx?SourceUrl=" + encodeURI(this.pathname);
    //        this.href = newDocUrl;
    //    }
    //});
}

SP.SOD.executeFunc('sp.js', 'SP.ClientContext', checkIfUserIsAuthenticated);

function checkIfUserIsAuthenticated() {
    clientContext = SP.ClientContext.get_current();
    website = clientContext.get_web();
    user = website.get_currentUser();

    clientContext.load(user);
    clientContext.executeQueryAsync(
        function () {
            // User is authenticated. Do nothing.
        },
        function () {
            if (isInternetExplorer()) {
                replaceDownloadLinks();

                $(document).ajaxStop(function () {
                    replaceDownloadLinks();
                });
            }
        });
}

}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/downloadOfficeDocuments.js","/")
},{"VCmEsw":4,"buffer":1}],8:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
$(document).ready(function () {
	require('./foldableContent.js');

	require('./mainMenu.js');

	require('./toggleArrowFunction.js');

	require('./footerTabs.js');

	require('./shareFunction.js');

	require('./guidesFunction.js');

	require('./sharePointUtilities.js');

	require('./addExternaliconFunction.js');

	require('./tooltip.js');

	require('./cookie.js');
	
	require('./printFunction.js');

	require('./downloadOfficeDocuments.js');

	require('./newsLetterDialog.js');

	// NLH 2015-11-04 + Helper functions like copy to clipboard, toggle technical info messages showed like cookie message, etc. 
	require('./helperFunctions.js');

});

$(window).load(function () {
	require('./gridGallerySizeFunction.js');

	require('./showAllRefiner.js');

	$.getScript('/_layouts/15/ScriptResx.ashx?name=FvstResource&culture=' + document.documentElement.lang)
     .done(function () { 
     	FVST = {}; 
     	FVST.Res = Res;
     })
     .fail(function () { 
     	console.log("error"); 
     });
});
}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/fake_cd5802e8.js","/")
},{"./addExternaliconFunction.js":5,"./cookie.js":6,"./downloadOfficeDocuments.js":7,"./foldableContent.js":9,"./footerTabs.js":10,"./gridGallerySizeFunction.js":11,"./guidesFunction.js":12,"./helperFunctions.js":13,"./mainMenu.js":14,"./newsLetterDialog.js":15,"./printFunction.js":16,"./shareFunction.js":17,"./sharePointUtilities.js":18,"./showAllRefiner.js":19,"./toggleArrowFunction.js":20,"./tooltip.js":21,"VCmEsw":4,"buffer":1}],9:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
//**FOR NEW SP2013 CODE**//
//mmc@netcompany.com - JS FUNCTION FOR ACCORDION CONTENT TYPOGRAPHY MENUS - 13-11-2014

var localizedShowMoreText = document.documentElement.lang == 'da-DK' ? "Vis alle" : "Show all";
var localizedShowLessText = document.documentElement.lang == 'da-DK' ? "Skjul alle" : "Hide all";

//HACK FOR SHOWING MORE DIVS AFTER TOGGLE BOXES

//MAKE OLD CONTENT FOLDABLE
$(document).ready(function () {
    var inViewMode = 0;
    if (typeof (PageState) === 'undefined') {
        inViewMode = 1;
    }
    else {
        if (typeof (PageState.ViewModeIsEdit) === 'undefined') {
            inViewMode = 1;
        }
        else {
            if (!PageState.ViewModeIsEdit) {
                inViewMode = 1;
            }
        }
    }
    
    if ($('#foldAnchor').length === 0 && inViewMode) {
        var selection = $('div.ms-rteElement-FoldHeading');

        //Create anchor, so we know where we started, before messing up the DOM
        selection.first().before('<div id="foldAnchor" />');

        foldFixUp(selection, $('#foldAnchor'));

        //Remove old obsolete class
        $("DIV.ms-rteElement-FoldContent").removeClass("ms-rteElement-FoldContent");
    }
});


var foldFixUp = function (headings, baseElem) {

    headings.each(function (index, element) {
        var myElem, content, contentAfter, foldElement, s;

        myElem = $(element);

        s = myElem.html();
        myElem.html('<a href="#">' + s + '</a>');

        //remove from the DOM the divs belonging to this heading.
        content = myElem.nextUntil("div.ms-rteElement-FoldHeading:first").detach(); // div:not('.fvst-rteElement-DIV-JSFold')"); to test for as-long-as. But SharePoint might insert extra empty DIVs which will break the script function
        contentAfter = myElem.parent().nextUntil("div.ms-rteElement-FoldHeading:first").detach();

        //Create new div, and attach the previous detached's divs inside it
        foldElement = $('<div class="fake-fold fake-fold-closed" />');
        foldElement = foldElement.append(content);
        foldElement = foldElement.append(contentAfter);

        //move the current headline
        baseElem.after(myElem);
        //attach the newly created element after the heading.
        baseElem.next().after(foldElement);
        baseElem = baseElem.next().next();
    });

    if($('#foldAnchor').length){
        webparts = $(".ms-webpart-zone").detach();
    }

    //ADDING SHOW/HIDE BUTTONS TOP
    $(".ms-rteElement-FoldHeading").first().before(function () {
        return"<div class='btn_group'>" +
                    "<div id='show1'>" +
                       "<span class='fa-stack toggle'>" +
                            "<i class='fa-li fa fa-circle-thin'></i>" +
                            "<i class='fa-li fa fa-angle-down'></i>" +
                        "</span>" +
                        "<li class='left-border'>" + localizedShowMoreText + "</li>" +   
                        "<li class='seperator'>|</li>" +
                    "</div>" +
                    
                    "<div id='hide1'>" +
                        "<span class='fa-stack toggle'>" +
                            "<i class='fa-li fa fa-circle-thin'></i>" +
                            "<i class='fa-li fa fa-angle-up'></i>" +
                        "</span>" +
                        "<li class='left-border'>" + localizedShowLessText + "</li> " +  
                    "</div>" +
               "</div>";
    });

    //ADDING SHOW/HIDE BUTTONS BOTTOM
    $('.fake-fold:last').after(function () {
        return"<div class='btn_group'> "+
                  "<div id='show2'>" +
                     "<span class='fa-stack toggle'>" +
                        "<i class='fa-li fa fa-circle-thin'></i>" +
                         "<i class='fa-li fa fa-angle-down'></i>" +
                    "</span>" +
                      "<li class='left-border'>" + localizedShowMoreText + "</li>   " +
                       "<li class='seperator'>|</li>" +
                  "</div>" +
                    
                  "<div id='hide2'>" +
                     "<span class='fa-stack toggle'>" +
                        "<i class='fa-li fa fa-circle-thin'></i>" +
                          "<i class='fa-li fa fa-angle-up'></i>" +
                        "</span>" +
                        "<li class='left-border'>" + localizedShowLessText + "</li> " +  
                 "</div>" +
            "</div>";
    });

    //ADD WEBPARTS
    if($('#foldAnchor').length){
        $('.btn_group:last').after(webparts);
    }

    //CLICK FUNCTION FOR TOGGLING CONTENT AND TOOGLE BETWEEN ICONS
    $(".ms-rteElement-FoldHeading").click(function() {
        var elem = $(this);

        $(this).next().slideToggle('slow', function() {
            if ($(this).is(':visible')) {
                $(elem).css("background-image", "url(/_layouts/15/Netcompany.FVS0001/images/minusicon.png)");
            } else {
                $(elem).css("background-image", "url(/_layouts/15/Netcompany.FVS0001/images/plusicon.png)");
            }
        });
        return false;
    });

    //CLIK FUCNTION FOR SHOW OR HIDE ALL
    $("#show1,#show2").click(function () {
        $(".fake-fold").show('fast');
        $(".ms-rteElement-FoldHeading").css("background-image", "url(/_layouts/15/Netcompany.FVS0001/images/minusicon.png)");
    });
    $("#hide1,#hide2").click(function () {
        $(".fake-fold").hide('fast');
        $(".ms-rteElement-FoldHeading").css("background-image", "url(/_layouts/15/Netcompany.FVS0001/images/plusicon.png)");
    });

};
}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/foldableContent.js","/")
},{"VCmEsw":4,"buffer":1}],10:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
//**FOR NEW SP2013 CODE**//
//mmc@netcompany.com - JS FUNCTION FOR MAIN MENU ICONS - 20-11-2014
//TO FIND THE CLICKED FOOTERTAB-ITEM AND TO HIGHLIGHT THE ONE THATS CLICKED.

//MAKE THE FIRST TAB CHECKED AND MAKE IT ACTIVE.
$(".tabs li input").first().attr('checked', 'checked');
$(".tabs li label").first().addClass('active');

//CHECK IF ANY TAB IS ACTIVE AND REMOVE ACTIVE CLASS
$(".tabs li label").click(function () {
    if($('.tabs li label').hasClass('active')){
        $('.tabs li label').removeClass('active');
    }
});

//MAKE CLICKED TAB ACTIVE
$(".tabs li label").click(function () {
        $(this).addClass('active');
});

//For accessibility using keyboard
//CHECK IF ANY TAB IS ACTIVE AND REMOVE ACTIVE CLASS
$(".tabs li").on("keypress click", "label", function () {
    if ($('.tabs li label').hasClass('active')) {
        $('.tabs li label').removeClass('active');
    }
});

//MAKE CLICKED TAB ACTIVE
$(".tabs li").on("keypress click", "label", function () {
    $(this).addClass('active');
    $(this).siblings('input[name=tabs]').click();
});

//MAKE MOBILE FOOTER ACCESSIBLE VIA KEYBOARD
$('.card').on('keyup', function (evt) {
if (evt.key === "Enter") {
    $(this).click();
}
});

//MAKE MOBILE MENU ACCESSIBLE VIA KEYBOARD  
$('.mobile-menu-img').on('keyup', function (evt) {
if (evt.key === "Enter") {
    $(this).click();
}

});
$('#mySidenav .fa-chevron-down, #mySidenav .fa-chevron-up').on('keyup', function (evt) {
    if (evt.key === "Enter") {
        $(this).click();
    }
});
$('#mySidenav').on('keyup', function (evt) {
    if (evt.key === "Escape") {
        closeNav();
    }
});
$('#Custom_Logo a').focusin(function (evt) {
    closeNav();
});

}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/footerTabs.js","/")
},{"VCmEsw":4,"buffer":1}],11:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
//**FOR NEW SP2013 CODE**//
//mmc@netcompany.com - FUNCTION TO MAKE DIVS UNDER IMG IN GRIDGALLERY TO BE SAME SIZE- 1-12-2014

//ADD CLASS TO FOUND DIV
var addGridItemParagraphClass = function(index, element, paragraphName) {
    $(element).addClass(paragraphName + index);
};

//GET THE BIGGEST DIV AND SET DIV WITH SAME ID TO THE BIGGEST SIZE
//var i = 1;
$("#col-left").find('.grid_item').each(function(index, element) {
	addGridItemParagraphClass(index, element, 'left_paragraph_');
});

$("#col-right").find('.grid_item').each(function(index, element) {
	addGridItemParagraphClass(index, element, 'right_paragraph_');
});

$(".gridgallery-list-item").each(function(index) {
	var left_paragraph = $('.left_paragraph_' + index);
	var right_paragraph =  $('.right_paragraph_' + index);

	var left_paragraph_height = left_paragraph.height();
	var right_paragraph_height =  right_paragraph.height();

	if(left_paragraph_height > right_paragraph_height) {
  		right_paragraph.css('height', left_paragraph_height + 'px');	  		
	} else {
  		left_paragraph.css('height', right_paragraph_height + 'px');
	}
});
}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/gridGallerySizeFunction.js","/")
},{"VCmEsw":4,"buffer":1}],12:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
//**FOR NEW SP2013 CODE**//
//mmc@netcompany.com - JS FUNCTION GUIDES FOLDIN/FOLDOUT- 25-11-2014

//JS FOR GUIDES FOLDIN/FOLDOUT - (FOR PAGES WITH AJAX CALL)
//TO MAKE THIS RENDER ON WINDOW LOAD NOT ON DOCUMENT READY.(Global Function)

//WE HAVE TO IMPORT 
	//GuideV2.js in here and cleanup and structur js in the file.  

}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/guidesFunction.js","/")
},{"VCmEsw":4,"buffer":1}],13:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/* 
	Copy data to clipboard without using Flash (see http://caniuse.com/#search=clipboard) 
	IE9, IE10 and IE11 supports clipboardData were user grants access. For other browser we show prompt, were user can copy the data with Ctrl+C shortcut key
*/
function copyToClipboard(element,copyText) {
	$(element).select();	 
	var text = $(element).val();
	if (copyText) text = $(element).text();
	try {
		if( window.clipboardData && clipboardData.setData ){ 
			window.clipboardData.setData("Text", text); 
		} 
		else {
			// If browser does not support the copy action exception is thrown and default behavior used
			document.execCommand("copy");
		}
	}
	catch(e) {
		// Default that works in all browsers
		window.prompt("Ctrl+C", text);
	} 
}

// Global message if shown everytime user refreshes the page, if more than 30 minutes has elapsed since last time it was displayed 
function showGlobalMessage() {

	// If not TechnicalStatus_Visible=0 if SharePoint backend list, then technical status messages are disabled all together
	if (!$('#global_message').hasClass("global_message_hide")) { 
		$('#global_message_close_btn').click(function(e){
			//$('#global_message').hide();
			//$('#s4-workspace').css("height","100%");
			e.preventDefault();

			var date = new Date();
			var minutes = $('#ctl00_ctl45_GlobalMessageCookieTimeout').val();
	 		date.setTime(date.getTime() + (minutes * 60 * 1000));
	 		var timestamp = $('#ctl00_ctl45_GlobalMessageTimestamp').val();
			$.cookie('globalMessageClosed', timestamp, {expires: date, path: '/' });
			location.reload(false);
		});
		// Check if user already closed global message today or if user control added hide css class to indicate global message was disabled server side
		var timestamp = $("#ctl00_ctl45_GlobalMessageTimestamp").val();

		//console.log('globalMessageClosed: '+$.cookie('globalMessageClosed')+'!=='+timestamp);
		if($.cookie('globalMessageClosed') !== timestamp) {
			$('#global_message').show();
		}
	}
}

/* Add speech bubble after search result is loaded
	parentSelector: 	Use jQuery selector to find parent of speech buble ".search_row_item th:last-child"
	id: 				Any id like "mybubble"
	html: 				Give som HTML text for the P tag like "Hello world!"
	className: 			Apply class pos0, pos1, pos2, pos3, pos4 to position of speech bubble top triangle  
function showSpeechBubble(parentSelector,id,html,className) {
	var pos = "pos0";
	if (className) pos = className;
	$(parentSelector).append('<p class="triagle-top-spacer"></p>');
	$(parentSelector).append('<p id="'+id+'"class="triangle-border top '+pos+'">'+html+'</p>');
}

function showSearchResultSpeechBubble(element) {
	var tr = $(element).parents(".search_row_item").next(".search_row_info");
	if (tr) {
		tr.css("display","table-row");
	}
}

function hideSearchResultSpeechBubble(element) {
	$(element).parent(".search_row_info").hide();
}

function toggleSearchResultSpeechBubble(element,event) {
	event.preventDefault();
	var tr = $(element).parents(".search_row_item").next(".search_row_info");
	if (tr) {
		if (tr.css("display") === "none") {
			tr.css("display","table-row");
		}
		else {
			tr.hide();			
		}
	}
	return false;
}

*/

(function(window, document, undefined){
    window.copyToClipboard = copyToClipboard;
    window.showGlobalMessage = showGlobalMessage;
    /*window.showSpeechBubble = showSpeechBubble;
    window.showSearchResultSpeechBubble = showSearchResultSpeechBubble;
    window.hideSearchResultSpeechBubble = hideSearchResultSpeechBubble;
    window.toggleSearchResultSpeechBubble = toggleSearchResultSpeechBubble;*/
})(window, document);

// Helper functions are called on document.ready in main.js
showGlobalMessage();

//Test speech bubble after any element
//showSpeechBubble(".search_row_item th:last-child","mybubble","Hello world!","pos4"); 
}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/helperFunctions.js","/")
},{"VCmEsw":4,"buffer":1}],14:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){

    //Set alt-tag="" for all images without alt-tag.
    //find better location for this code?
    $(document).ready(function () {
        $('body img').each(function () {
            if (!$(this).attr('alt')) {
                //set the alt text if the attribute is not found as below
                $(this).attr('alt', "");
            }
        });
    });


    $('.profession_list, .situation_list').on('keyup', 'ul > li > a', function (evt) {
        if (evt.key === "Escape") {
            search_profession();
            $('#search_profession_id').focus();
        }
    });

    $(window).load(function () {
        $('#extended_search').find('#SearchBox').on('keyup', 'input, a', function (evt) {
            if (evt.key === "Escape") {
                search_click();
                $('#search_icon_wrapper_id').focus();
            }
        });
    });

    //**WCAG UPDATE TO MAINMENU**//
    //**See Jquery-accessibleMegaMenu.js aswell **//

    $("#global_nav").accessibleMegaMenu({
        /* prefix for generated unique id attributes, which are required 
           to indicate aria-owns, aria-controls and aria-labelledby */
        uuidPrefix: "accessible-megamenu",

        /* css class used to define the megamenu styling */
        menuClass: "nav-menu",

        /* css class for a top-level navigation item in the megamenu */
        topNavItemClass: "nav-item",

        /* css class for a megamenu panel */
        panelClass: "sub-nav",

        /* css class for a group of items within a megamenu panel */
        panelGroupClass: "sub-nav-group",

        /* css class for the hover state */
        hoverClass: "hover",

        /* css class for the focus state */
        focusClass: "focus",

        /* css class for the open state */
        openClass: "open"
    });

    // SHOW AND HIDE SEARCH PROFESSION
    $(window).click(function (e) {
        if ($(e.target).is("#search-profession-toggle-btn")) {
            search_profession_close_other();
            $(".TopMenuBarLink.open").find("label").click();
        }
        else if ($(e.target).is("#search-toggle-btn")) {
            search_click_close_others();
            $(".TopMenuBarLink.open").find("label").click();
        }

    });

    function search_profession() {
        if ($("#search-profession-toggle-btn").prop("checked") == false) {
            //Open Search profession
            $("#search-profession-toggle-btn").prop("checked", true);
            $('#extended_search_profession > div > div.profession_list.noindex > ul > li:nth-child(1) > a').focus();
        }
        else {
            //Search-profession is closed
            $("#search-profession-toggle-btn").prop("checked", false);
        }

        search_profession_close_other();
    }

    function search_click() {
        if ($("#search-toggle-btn").prop("checked") == false) {
            //Open Search
            $("#search-toggle-btn").prop("checked", true);
            $('#ctl00_PlaceHolderSearchArea_ctl00_csr_sbox').focus();
            
        }
        else {
            //Close search
            $("#search-toggle-btn").prop("checked", false);
        }
        search_click_close_others();
    }

    function search_profession_close_other() {
        if ($("#search-profession-toggle-btn").prop("checked") == true) {
            //Close other menu tabs
            $(".TopMenuBarLink.open").find("label").click();

            if ($("#search-toggle-btn").prop("checked") == true) {
                $("#search-toggle-btn").prop("checked", false);
            }

        }
    }

    function search_click_close_others() {
        if ($("#search-toggle-btn").prop("checked") == true) {

            //Close other menu tabs
            $(".TopMenuBarLink.open").find("label").click();
            if ($("#search-profession-toggle-btn").prop("checked") == true) {
                $("#search-profession-toggle-btn").prop("checked", false);
            }
        }

    }
    (function (window, document, undefined) {
        window.search_click = search_click;
        window.search_profession = search_profession;
        window.search_profession_close_other = search_profession_close_other;
        window.search_click_close_others = search_click_close_others;
    })(window, document);

}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/mainMenu.js","/")
},{"VCmEsw":4,"buffer":1}],15:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
function showNewsletterDialog(dialogUrl) {
    var dialog = {
        url: dialogUrl,
        title: 'Tilføj til nyhedsbrev',
        allowMaximize: true,
        showClose: true,
        width: 420,
        height: 580,
        dialogReturnValueCallback: function (dialogResult) {
            if (dialogResult == SP.UI.DialogResult.OK) {
                var statusOkId;
                statusOkId = SP.UI.Status.addStatus("Nyhedsbrev:", "Siden er tilføjet til valgte emne(r)");
                SP.UI.Status.setStatusPriColor(statusOkId, "green");
                setTimeout(function () { SP.UI.Status.removeStatus(statusOkId); }, 5000);
            } else {
                var statusCancelId;
                statusCancelId = SP.UI.Status.addStatus("Nyhedsbrev:", "Siden blev ikke tilføjet da et eller flere emner ikke blev valgt");
                SP.UI.Status.setStatusPriColor(statusCancelId, "yellow");
                setTimeout(function () { SP.UI.Status.removeStatus(statusCancelId); }, 5000);
            }
        }
    };

    SP.UI.ModalDialog.showModalDialog(dialog);
}

function showSendNewsLetterDialog(dialogUrl) {
    var dialog = {
        url: dialogUrl,
        title: 'Send nyhedsbrev',
        allowMaximize: true,
        showClose: true,
        width: 460,
        height: 260,
        dialogReturnValueCallback: function (dialogResult) {
            if (dialogResult == SP.UI.DialogResult.OK) {
                var statusOkId;
                statusOkId = SP.UI.Status.addStatus("Nyhedsbrev:", "Er under afsendelse...");
                SP.UI.Status.setStatusPriColor(statusOkId, "green");
                setTimeout(function () { SP.UI.Status.removeStatus(statusOkId); }, 5000);
            } else {
                var statusCancelId;
                statusCancelId = SP.UI.Status.addStatus("Nyhedsbrev:", "Blev ikke afsendt da vinduet blev lukket");
                SP.UI.Status.setStatusPriColor(statusCancelId, "yellow");
                setTimeout(function () { SP.UI.Status.removeStatus(statusCancelId); }, 5000);
            }
        }
    };

    SP.UI.ModalDialog.showModalDialog(dialog);
}

(function(window, document, undefined){
    window.showNewsletterDialog = showNewsletterDialog;
    window.showSendNewsLetterDialog = showSendNewsLetterDialog;
})(window, document);
}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/newsLetterDialog.js","/")
},{"VCmEsw":4,"buffer":1}],16:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
(function () {
    var beforePrint = function () {
        $("div,a,h3,h2,h1,p,span,time").css("font-family", "Segoe UI");
        //Fold everything out
        $(".fake-fold").show();
        $(".ms-rteElement-FoldHeading").css("background-image", "url(/_layouts/15/Netcompany.FVS0001/images/minusicon.png)");
    };
    var afterPrint = function () {
        $(".fake-fold").hide();
        $(".ms-rteElement-FoldHeading").css("background-image", "url(/_layouts/15/Netcompany.FVS0001/images/plusicon.png)");
    };

    if (window.matchMedia) {
        var mediaQueryList = window.matchMedia('print');
        mediaQueryList.addListener(function (mql) {
            if (mql.matches) {
                beforePrint();
            } else {
                afterPrint();
            }
        });
    }

    window.onbeforeprint = beforePrint;
    window.onafterprint = afterPrint;
}());
}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/printFunction.js","/")
},{"VCmEsw":4,"buffer":1}],17:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
//**FOR NEW SP2013 CODE**//
//mmc@netcompany.com - Toggle Share-btn - 20-11-2014

//Service menu
$(".share").click(function () {
    $(".share_btns").slideToggle('show');
});
}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/shareFunction.js","/")
},{"VCmEsw":4,"buffer":1}],18:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){

(function(window, document, undefined){

    window.SharePointUtilities = window.SharePointUtilities || {};

    /*
    window.SharePointUtilities.showDialog = function (url, title, height, width) {
        var options = {
            url: url, //+ "&IsDlg=1",
            title: title,
            allowMaximize: true,
            showClose: true,
            width: width,
            height: height,
            dialogReturnValueCallback: dialogCallback
        };
        SP.SOD.execute('sp.ui.dialog.js', 'SP.UI.ModalDialog.showModalDialog', options);
        return false;
    };

    function dialogCallback(result, response) {
        switch (result) {
            case SP.UI.DialogResult.cancel:
                //do nothing
                break;
            case SP.UI.DialogResult.invalid:
                //do nothing
                break;
            case SP.UI.DialogResult.ok:
                var note = SP.UI.Notify.addNotification(response.message);
                break;
        }
    }
    */


    //function to open pages in a dialog
    function openInDialog(dlgWidth, dlgHeight, dlgAllowMaximize,dlgShowClose,needCallbackFunction, pageUrl) 
    {    
        var options = { url: pageUrl, width: dlgWidth, height: dlgHeight, allowMaximize: dlgAllowMaximize,
            showClose: dlgShowClose     
            };
            
        if(needCallbackFunction)
        {
            options.dialogReturnValueCallback = Function.createDelegate(null, CloseDialogCallback);
        }
        SP.SOD.execute('sp.ui.dialog.js', 'SP.UI.ModalDialog.showModalDialog', options);
    }

    function CloseDialogCallback(dialogResult, returnValue)
    {
        //if user click on OK or Save
         if(dialogResult == SP.UI.DialogResult.OK)
         {  // refresh parent page
            SP.SOD.execute('sp.ui.dialog.js', 'SP.UI.ModalDialog.RefreshPage', SP.UI.DialogResult.OK);          
         }
         // if user click on Close or Cancel
         else if(dialogResult == SP.UI.DialogResult.cancel)
         {  // Do Nothing or add any logic you want 
         }
         else
         {//alert("else " + dialogResult);
         }
    }

    window.SharePointUtilities.openInDialog = openInDialog;

})(window, document);

}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/sharePointUtilities.js","/")
},{"VCmEsw":4,"buffer":1}],19:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
//TO MAKE THIS RENDER ON WINDOW LOAD NOT ON DOCUMENT READY.(Global Function)
(function(window, document, undefined){
  	window.toggleShowButton = function(showButton){
	  	var selector = $(showButton);
		selector.parent().siblings().find('.hidden_refiner_list').slideToggle('slow');				        

		var localizedShowMoreText = document.documentElement.lang == 'da-DK' ? "Vis flere" : "Show more";
		var localizedShowLessText = document.documentElement.lang == 'da-DK' ? "Vis færre" : "Show less";

		var showButtonText = (selector.html() == localizedShowLessText ? localizedShowMoreText : localizedShowLessText);
		selector.html(showButtonText);
	};
})(window, document);
}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/showAllRefiner.js","/")
},{"VCmEsw":4,"buffer":1}],20:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/////////!!!!!!! Make comments and make functions reusabel as variable////////////////////////!!!!!!

//**FOR NEW SP2013 CODE**//
//mmc@netcompany.com - ToggleFunctions - 19-11-2014

//Service menu
// FOR TOOGLE ARROW UP AND DOWN INSIDE CIRCLE 
$(".toggle").click(function () {
    $(".toggle_arrow").toggleClass('fa-angle-down fa-angle-up');
});

//TOGGLE CHEVRONS (!!!!!!!!!!MAYBE REMOVE THIS!!!!!!!!!!!!!) 
$(".toggle_chevron").click(function () {
    $(this).find('i').toggleClass('fa-chevron-down fa-chevron-up');
});

//TOGGLE + - icons - IS USED ON ALL GUIDE ROOLUP ! 
/*$(".toggle_btn").click(function () {
    $(this).find('i').toggleClass('plus_icon minus_icon');
    $(this).find(".PickerShowAll").toggleClass("PickerHideShow-None");
});*/

// NEW TOGGLE + - icons AND ShowAll HideAll
$(".toggle_btn").find('input').change(function(){
	$(this).parent().find('i').first().toggleClass('plus_icon minus_icon');
    $(this).parent().find(".PickerShowAll").toggleClass("PickerHideShow-None");
});

$(".PickerShow, .plus_minus").click(function() {
    $(this).closest('.toggle_btn').find('input').trigger('click');
});

//TOGGLE + - icons - IS USED ON ALL GUIDE ROOLUP !
$(".template_toggle_btn").click(function () {
    $(this).find('i').toggleClass('plus_icon minus_icon');
});

//FOR STD SHAREPOINT WEBPART
if($(".top_refiner_container input:checked")){
    $(".top_refiner_container input:checked").next('label').addClass('active_refiner');
}

// NLH 2015-11-03 : Add icons for external urls only
$(".textrotator_manchet").find("a").each(function( index ) {
  var href = $(this).attr("href");
  if (href && href.indexOf('http')===0) {
  	 $(this).addClass("external-url");
  }
  else {
  	 $(this).addClass("internal-url");	
  }
});


}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/toggleArrowFunction.js","/")
},{"VCmEsw":4,"buffer":1}],21:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
$('.tooltip').tooltipster({
	multiple: true,
	position: 'top'
});
}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/tooltip.js","/")
},{"VCmEsw":4,"buffer":1}]},{},[8])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxTb3VyY2VcXEZTX0J1aWxkXFxVSVxcRmluZFNtaWxleVxcbm9kZV9tb2R1bGVzXFxndWxwLWJyb3dzZXJpZnlcXG5vZGVfbW9kdWxlc1xcYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxicm93c2VyLXBhY2tcXF9wcmVsdWRlLmpzIiwiQzovU291cmNlL0ZTX0J1aWxkL1VJL0ZpbmRTbWlsZXkvbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwiQzovU291cmNlL0ZTX0J1aWxkL1VJL0ZpbmRTbWlsZXkvbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIkM6L1NvdXJjZS9GU19CdWlsZC9VSS9GaW5kU21pbGV5L25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIkM6L1NvdXJjZS9GU19CdWlsZC9VSS9GaW5kU21pbGV5L25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIkM6L1NvdXJjZS9GU19CdWlsZC9VSS9GaW5kU21pbGV5L3NjcmlwdHMvYWRkRXh0ZXJuYWxpY29uRnVuY3Rpb24uanMiLCJDOi9Tb3VyY2UvRlNfQnVpbGQvVUkvRmluZFNtaWxleS9zY3JpcHRzL2Nvb2tpZS5qcyIsIkM6L1NvdXJjZS9GU19CdWlsZC9VSS9GaW5kU21pbGV5L3NjcmlwdHMvZG93bmxvYWRPZmZpY2VEb2N1bWVudHMuanMiLCJDOi9Tb3VyY2UvRlNfQnVpbGQvVUkvRmluZFNtaWxleS9zY3JpcHRzL2Zha2VfY2Q1ODAyZTguanMiLCJDOi9Tb3VyY2UvRlNfQnVpbGQvVUkvRmluZFNtaWxleS9zY3JpcHRzL2ZvbGRhYmxlQ29udGVudC5qcyIsIkM6L1NvdXJjZS9GU19CdWlsZC9VSS9GaW5kU21pbGV5L3NjcmlwdHMvZm9vdGVyVGFicy5qcyIsIkM6L1NvdXJjZS9GU19CdWlsZC9VSS9GaW5kU21pbGV5L3NjcmlwdHMvZ3JpZEdhbGxlcnlTaXplRnVuY3Rpb24uanMiLCJDOi9Tb3VyY2UvRlNfQnVpbGQvVUkvRmluZFNtaWxleS9zY3JpcHRzL2d1aWRlc0Z1bmN0aW9uLmpzIiwiQzovU291cmNlL0ZTX0J1aWxkL1VJL0ZpbmRTbWlsZXkvc2NyaXB0cy9oZWxwZXJGdW5jdGlvbnMuanMiLCJDOi9Tb3VyY2UvRlNfQnVpbGQvVUkvRmluZFNtaWxleS9zY3JpcHRzL21haW5NZW51LmpzIiwiQzovU291cmNlL0ZTX0J1aWxkL1VJL0ZpbmRTbWlsZXkvc2NyaXB0cy9uZXdzTGV0dGVyRGlhbG9nLmpzIiwiQzovU291cmNlL0ZTX0J1aWxkL1VJL0ZpbmRTbWlsZXkvc2NyaXB0cy9wcmludEZ1bmN0aW9uLmpzIiwiQzovU291cmNlL0ZTX0J1aWxkL1VJL0ZpbmRTbWlsZXkvc2NyaXB0cy9zaGFyZUZ1bmN0aW9uLmpzIiwiQzovU291cmNlL0ZTX0J1aWxkL1VJL0ZpbmRTbWlsZXkvc2NyaXB0cy9zaGFyZVBvaW50VXRpbGl0aWVzLmpzIiwiQzovU291cmNlL0ZTX0J1aWxkL1VJL0ZpbmRTbWlsZXkvc2NyaXB0cy9zaG93QWxsUmVmaW5lci5qcyIsIkM6L1NvdXJjZS9GU19CdWlsZC9VSS9GaW5kU21pbGV5L3NjcmlwdHMvdG9nZ2xlQXJyb3dGdW5jdGlvbi5qcyIsIkM6L1NvdXJjZS9GU19CdWlsZC9VSS9GaW5kU21pbGV5L3NjcmlwdHMvdG9vbHRpcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmxDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MlxuXG4vKipcbiAqIElmIGBCdWZmZXIuX3VzZVR5cGVkQXJyYXlzYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKGNvbXBhdGlibGUgZG93biB0byBJRTYpXG4gKi9cbkJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgPSAoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgaWYgYnJvd3NlciBzdXBwb3J0cyBUeXBlZCBBcnJheXMuIFN1cHBvcnRlZCBicm93c2VycyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLFxuICAvLyBDaHJvbWUgNyssIFNhZmFyaSA1LjErLCBPcGVyYSAxMS42KywgaU9TIDQuMisuIElmIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgYWRkaW5nXG4gIC8vIHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcywgdGhlbiB0aGF0J3MgdGhlIHNhbWUgYXMgbm8gYFVpbnQ4QXJyYXlgIHN1cHBvcnRcbiAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gYWRkIGFsbCB0aGUgbm9kZSBCdWZmZXIgQVBJIG1ldGhvZHMuIFRoaXMgaXMgYW4gaXNzdWVcbiAgLy8gaW4gRmlyZWZveCA0LTI5LiBOb3cgZml4ZWQ6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOFxuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiZcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAvLyBDaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG5cbiAgLy8gV29ya2Fyb3VuZDogbm9kZSdzIGJhc2U2NCBpbXBsZW1lbnRhdGlvbiBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgc3RyaW5nc1xuICAvLyB3aGlsZSBiYXNlNjQtanMgZG9lcyBub3QuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcgJiYgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzdWJqZWN0ID0gc3RyaW5ndHJpbShzdWJqZWN0KVxuICAgIHdoaWxlIChzdWJqZWN0Lmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0ICsgJz0nXG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gIHZhciBsZW5ndGhcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKVxuICAgIGxlbmd0aCA9IGNvZXJjZShzdWJqZWN0KVxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJylcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpXG4gICAgbGVuZ3RoID0gY29lcmNlKHN1YmplY3QubGVuZ3RoKSAvLyBhc3N1bWUgdGhhdCBvYmplY3QgaXMgYXJyYXktbGlrZVxuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgYXJyYXkgb3Igc3RyaW5nLicpXG5cbiAgdmFyIGJ1ZlxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIC8vIFByZWZlcnJlZDogUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBidWYgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIFRISVMgaW5zdGFuY2Ugb2YgQnVmZmVyIChjcmVhdGVkIGJ5IGBuZXdgKVxuICAgIGJ1ZiA9IHRoaXNcbiAgICBidWYubGVuZ3RoID0gbGVuZ3RoXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBidWYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkpXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgICBlbHNlXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3RbaV1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIUJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgJiYgIW5vWmVybykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYnVmW2ldID0gMFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuLy8gU1RBVElDIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiAoYikge1xuICByZXR1cm4gISEoYiAhPT0gbnVsbCAmJiBiICE9PSB1bmRlZmluZWQgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIgKyAnJ1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoIC8gMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdyYXcnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAqIDJcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGFzc2VydChpc0FycmF5KGxpc3QpLCAnVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdCwgW3RvdGFsTGVuZ3RoXSlcXG4nICtcbiAgICAgICdsaXN0IHNob3VsZCBiZSBhbiBBcnJheS4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB0b3RhbExlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICB0b3RhbExlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWxMZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcih0b3RhbExlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyBCVUZGRVIgSU5TVEFOQ0UgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gX2hleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgYXNzZXJ0KHN0ckxlbiAlIDIgPT09IDAsICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBhc3NlcnQoIWlzTmFOKGJ5dGUpLCAnSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlXG4gIH1cbiAgQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBpICogMlxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBfdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX2FzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX2JpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIF9hc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gX2Jhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBfdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gX2hleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IF91dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gX2FzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IF9iaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gX2Jhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBfdXRmMTZsZVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcbiAgc3RhcnQgPSBOdW1iZXIoc3RhcnQpIHx8IDBcbiAgZW5kID0gKGVuZCAhPT0gdW5kZWZpbmVkKVxuICAgID8gTnVtYmVyKGVuZClcbiAgICA6IGVuZCA9IHNlbGYubGVuZ3RoXG5cbiAgLy8gRmFzdHBhdGggZW1wdHkgc3RyaW5nc1xuICBpZiAoZW5kID09PSBzdGFydClcbiAgICByZXR1cm4gJydcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gX2hleFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IF91dGY4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gX2FzY2lpU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IF9iaW5hcnlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gX2Jhc2U2NFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBfdXRmMTZsZVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0X3N0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzXG5cbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKCF0YXJnZXRfc3RhcnQpIHRhcmdldF9zdGFydCA9IDBcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCBzb3VyY2UubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGFzc2VydChlbmQgPj0gc3RhcnQsICdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpXG4gIGFzc2VydCh0YXJnZXRfc3RhcnQgPj0gMCAmJiB0YXJnZXRfc3RhcnQgPCB0YXJnZXQubGVuZ3RoLFxuICAgICAgJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSBzb3VyY2UubGVuZ3RoLCAnc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aClcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KVxuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydFxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmIChsZW4gPCAxMDAgfHwgIUJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRfc3RhcnQpXG4gIH1cbn1cblxuZnVuY3Rpb24gX2Jhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJlcyA9ICcnXG4gIHZhciB0bXAgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoYnVmW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gICAgICB0bXAgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApXG59XG5cbmZ1bmN0aW9uIF9hc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKylcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gX2JpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIF9hc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gX2hleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gX3V0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSsxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSBjbGFtcChzdGFydCwgbGVuLCAwKVxuICBlbmQgPSBjbGFtcChlbmQsIGxlbiwgbGVuKVxuXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgdmFyIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCwgdHJ1ZSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgICByZXR1cm4gbmV3QnVmXG4gIH1cbn1cblxuLy8gYGdldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIF9yZWFkVUludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV1cbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZFVJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDJdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgICB2YWwgfD0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApXG4gIH0gZWxzZSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMV0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMl0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAzXVxuICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0XSA8PCAyNCA+Pj4gMClcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICB2YXIgbmVnID0gdGhpc1tvZmZzZXRdICYgMHg4MFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gX3JlYWRJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSBfcmVhZFVJbnQxNihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gX3JlYWRVSW50MzIoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMDAwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZmZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkRmxvYXQgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWREb3VibGUgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWREb3VibGUodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWREb3VibGUodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuXG5cbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbn1cblxuZnVuY3Rpb24gX3dyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAgICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZmZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICB0aGlzLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICB0aGlzLndyaXRlVUludDgoMHhmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgX3dyaXRlVUludDE2KGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIF93cml0ZVVJbnQxNihidWYsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIF93cml0ZVVJbnQzMihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICBfd3JpdGVVSW50MzIoYnVmLCAweGZmZmZmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApXG4gIH1cblxuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpLCAndmFsdWUgaXMgbm90IGEgbnVtYmVyJylcbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgdGhpcy5sZW5ndGgsICdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSB0aGlzLmxlbmd0aCwgJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHRoaXNbaV0gPSB2YWx1ZVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG91dCA9IFtdXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpc1tpXSlcbiAgICBpZiAoaSA9PT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIG91dC5qb2luKCcgJykgKyAnPidcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpXG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgZ2V0L3NldCBtZXRob2RzIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX2dldCA9IGFyci5nZXRcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZCwgd2lsbCBiZSByZW1vdmVkIGluIG5vZGUgMC4xMytcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcbmZ1bmN0aW9uIGNsYW1wIChpbmRleCwgbGVuLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHJldHVybiBkZWZhdWx0VmFsdWVcbiAgaW5kZXggPSB+fmluZGV4OyAgLy8gQ29lcmNlIHRvIGludGVnZXIuXG4gIGlmIChpbmRleCA+PSBsZW4pIHJldHVybiBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICBpbmRleCArPSBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBjb2VyY2UgKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpXG4gIHJldHVybiBsZW5ndGggPCAwID8gMCA6IGxlbmd0aFxufVxuXG5mdW5jdGlvbiBpc0FycmF5IChzdWJqZWN0KSB7XG4gIHJldHVybiAoQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoc3ViamVjdCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ViamVjdCkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgfSkoc3ViamVjdClcbn1cblxuZnVuY3Rpb24gaXNBcnJheWlzaCAoc3ViamVjdCkge1xuICByZXR1cm4gaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGIgPD0gMHg3RilcbiAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gaVxuICAgICAgaWYgKGIgPj0gMHhEODAwICYmIGIgPD0gMHhERkZGKSBpKytcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5zbGljZShzdGFydCwgaSsxKSkuc3Vic3RyKDEpLnNwbGl0KCclJylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKylcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShzdHIpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgcG9zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyIChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuXG4vKlxuICogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYSB2YWxpZCBpbnRlZ2VyLiBUaGlzIG1lYW5zIHRoYXQgaXRcbiAqIGlzIG5vbi1uZWdhdGl2ZS4gSXQgaGFzIG5vIGZyYWN0aW9uYWwgY29tcG9uZW50IGFuZCB0aGF0IGl0IGRvZXMgbm90XG4gKiBleGNlZWQgdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ1aW50ICh2YWx1ZSwgbWF4KSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA+PSAwLCAnc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmc2ludCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmSUVFRTc1NCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAodGVzdCwgbWVzc2FnZSkge1xuICBpZiAoIXRlc3QpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdGYWlsZWQgYXNzZXJ0aW9uJylcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJWQ21Fc3dcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLlxcXFxub2RlX21vZHVsZXNcXFxcZ3VscC1icm93c2VyaWZ5XFxcXG5vZGVfbW9kdWxlc1xcXFxicm93c2VyaWZ5XFxcXG5vZGVfbW9kdWxlc1xcXFxidWZmZXJcXFxcaW5kZXguanNcIixcIi8uLlxcXFxub2RlX21vZHVsZXNcXFxcZ3VscC1icm93c2VyaWZ5XFxcXG5vZGVfbW9kdWxlc1xcXFxicm93c2VyaWZ5XFxcXG5vZGVfbW9kdWxlc1xcXFxidWZmZXJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXHR2YXIgUExVU19VUkxfU0FGRSA9ICctJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSF9VUkxfU0FGRSA9ICdfJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMgfHxcblx0XHQgICAgY29kZSA9PT0gUExVU19VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0ggfHxcblx0XHQgICAgY29kZSA9PT0gU0xBU0hfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJWQ21Fc3dcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLlxcXFxub2RlX21vZHVsZXNcXFxcZ3VscC1icm93c2VyaWZ5XFxcXG5vZGVfbW9kdWxlc1xcXFxicm93c2VyaWZ5XFxcXG5vZGVfbW9kdWxlc1xcXFxidWZmZXJcXFxcbm9kZV9tb2R1bGVzXFxcXGJhc2U2NC1qc1xcXFxsaWJcXFxcYjY0LmpzXCIsXCIvLi5cXFxcbm9kZV9tb2R1bGVzXFxcXGd1bHAtYnJvd3NlcmlmeVxcXFxub2RlX21vZHVsZXNcXFxcYnJvd3NlcmlmeVxcXFxub2RlX21vZHVsZXNcXFxcYnVmZmVyXFxcXG5vZGVfbW9kdWxlc1xcXFxiYXNlNjQtanNcXFxcbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiVkNtRXN3XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi5cXFxcbm9kZV9tb2R1bGVzXFxcXGd1bHAtYnJvd3NlcmlmeVxcXFxub2RlX21vZHVsZXNcXFxcYnJvd3NlcmlmeVxcXFxub2RlX21vZHVsZXNcXFxcYnVmZmVyXFxcXG5vZGVfbW9kdWxlc1xcXFxpZWVlNzU0XFxcXGluZGV4LmpzXCIsXCIvLi5cXFxcbm9kZV9tb2R1bGVzXFxcXGd1bHAtYnJvd3NlcmlmeVxcXFxub2RlX21vZHVsZXNcXFxcYnJvd3NlcmlmeVxcXFxub2RlX21vZHVsZXNcXFxcYnVmZmVyXFxcXG5vZGVfbW9kdWxlc1xcXFxpZWVlNzU0XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiVkNtRXN3XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi5cXFxcbm9kZV9tb2R1bGVzXFxcXGd1bHAtYnJvd3NlcmlmeVxcXFxub2RlX21vZHVsZXNcXFxcYnJvd3NlcmlmeVxcXFxub2RlX21vZHVsZXNcXFxccHJvY2Vzc1xcXFxicm93c2VyLmpzXCIsXCIvLi5cXFxcbm9kZV9tb2R1bGVzXFxcXGd1bHAtYnJvd3NlcmlmeVxcXFxub2RlX21vZHVsZXNcXFxcYnJvd3NlcmlmeVxcXFxub2RlX21vZHVsZXNcXFxccHJvY2Vzc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblxyXG4vL0FERCBJQ09OIFRPIExJTktTIFRIQVQgSEFTIEVYVEVSTkFMIExJTktcclxuJChcImFbdGFyZ2V0PV9ibGFua11cIikuZWFjaChmdW5jdGlvbiAoKSB7ICAgXHJcblxyXG5cdGlmICggJChcImFbdGFyZ2V0PV9ibGFua11cIikuaGFzKFwiaW1nXCIpLmxlbmd0aCApXHJcblx0e1xyXG5cdFx0JCh0aGlzKS5yZW1vdmVDbGFzcyhcImV4dGVybmFsLXVybFwiKTtcclxuXHR9XHJcblx0ZWxzZVxyXG5cdHtcclxuXHRcdCAkKHRoaXMpLmFkZENsYXNzKCdleHRlcm5hbC11cmwnKTtcclxuXHR9ICAgIFxyXG59KTsgXHJcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJWQ21Fc3dcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9hZGRFeHRlcm5hbGljb25GdW5jdGlvbi5qc1wiLFwiL1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblxyXG4vLyBJRiBDT09LSUUgRE9FUyBOT1QgRVhJU1RTLCBTSE9XIENPT0tJRSBQT1BVUFxyXG5pZigkLmNvb2tpZSgnYW5hbHl0aWNzQWNjZXB0ZWQnKSA9PT0gdW5kZWZpbmVkKSB7XHJcblxyXG5cdC8vIFNIT1cgQ09PS0lFIFBPUFVQXHJcblx0JCgnI2Nvb2tpZXNfdmlld2VyJykuc2hvdygpO1xyXG5cclxuXHQvLyBJRiBDT09LSUUgSVMgQUNDRVBURUQgXHJcblx0JCgnI2Nvb2tpZV9hY2NlcHQnKS5jbGljayhmdW5jdGlvbihlKXtcclxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdHNldENvb2tpZUFjY2VwdGFuY2UoKTtcclxuXHR9KTtcclxuXHJcblx0Ly8gSUYgQ09PS0lFIElTIEFDQ0VQVEVEIFxyXG5cdCQoJyNjb29raWVfY2FuY2VsJykuY2xpY2soZnVuY3Rpb24oZSl7XHJcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHQkKCcjY29va2llc192aWV3ZXInKS5oaWRlKCk7XHJcblx0fSk7XHJcblxyXG5cdC8vIElmIHRoZSB1c2VyIHN0YXJ0cyB0byBjbGljayBhcm91bmQsIGhpZGUgdGhlIGNvb2tpZSB2aWV3ZXIgYW5kIHN0b3JlIGNvb2tpZVxyXG4gICAgJChcImRpdiNzNC1ib2R5Q29udGFpbmVyIGFcIikuY2xpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNldENvb2tpZUFjY2VwdGFuY2UoKTtcclxuICAgIH0pO1xyXG59XHJcbmVsc2Uge1xyXG5cdHNldENvb2tpZUFjY2VwdGFuY2UoKTtcdFxyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRDb29raWVBY2NlcHRhbmNlKCkge1xyXG5cclxuXHRmdW5jdGlvbiBsb2FkU2l0ZUltcHJvdmUoKXtcclxuXHQgICAgdmFyIHN6ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XHJcblx0ICAgIHN6LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcclxuXHQgICAgc3ouYXN5bmMgPSB0cnVlO1xyXG5cdCAgICBzei5zcmMgPSAnLy9zc2wuc2l0ZWltcHJvdmUuY29tL2pzL3NpdGVhbmFseXplXzI2MDMzNi5qcyc7XHJcblx0ICAgIHZhciBzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xyXG5cdCAgICBzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN6LCBzKTtcclxuXHR9XHJcblxyXG5cdC8vIEhpZGUgdGhlIGNvb2tpZSB2aWV3LCBhbmQgc3RvcmUgY29va2llXHJcblx0JCgnI2Nvb2tpZXNfdmlld2VyJykuaGlkZSgpO1xyXG5cdCQuY29va2llKCdhbmFseXRpY3NBY2NlcHRlZCcsIFwiMVwiLCB7ZXhwaXJlczogMzY1LCBwYXRoOiAnLycgfSk7XHJcblxyXG5cdC8vIExvYWQgc2l0ZS1pbXByb3ZlXHJcblx0bG9hZFNpdGVJbXByb3ZlKCk7XHJcbn1cclxuXHJcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJWQ21Fc3dcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9jb29raWUuanNcIixcIi9cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG7vu792YXIgY2xpZW50Q29udGV4dDtcclxudmFyIHdlYnNpdGU7XHJcbnZhciB1c2VyO1xyXG5cclxuZnVuY3Rpb24gaXNJbnRlcm5ldEV4cGxvcmVyKCkge1xyXG4gICAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XHJcbiAgICB2YXIgbXNpZSA9IHVhLmluZGV4T2YoXCJNU0lFIFwiKTtcclxuXHJcbiAgICBpZiAobXNpZSA+IDAgfHwgISFuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9UcmlkZW50LipydlxcOjExXFwuLykpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXBsYWNlRG93bmxvYWRMaW5rcygpIHtcclxuICAgIHZhciB1cGRhdGVGaWxlRXh0ID0gbmV3IEFycmF5KFwiLmRvY1wiLCBcIi5kb2N4XCIsIFwiLnhsc1wiLCBcIi54bHN4XCIsIFwiLnBwdFwiLCBcIi5wcHR4XCIpO1xyXG4gICAgdmFyIGNoZWNrU3RyaW5nID0gXCJcIjtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZUZpbGVFeHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjaGVja1N0cmluZyArPSAnYVtocmVmJD1cIicgKyB1cGRhdGVGaWxlRXh0W2ldICsgJ1wiXSwgYVtocmVmJD1cIicgKyB1cGRhdGVGaWxlRXh0W2ldLnRvVXBwZXJDYXNlKCkgKyAnXCJdLCAnO1xyXG4gICAgfVxyXG5cclxuICAgIGNoZWNrU3RyaW5nID0gY2hlY2tTdHJpbmcuc3Vic3RyaW5nKDAsIGNoZWNrU3RyaW5nLmxlbmd0aCAtIDIpO1xyXG5cclxuICAgICQoY2hlY2tTdHJpbmcpLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICgodGhpcy5ocmVmLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcIi9fbGF5b3V0cy9kb3dubG9hZC5hc3B4P3NvdXJjZXVybD1cIikgPiAwKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdmFyIG5ld0RvY1VybCA9IFwiL19sYXlvdXRzL2Rvd25sb2FkLmFzcHg/U291cmNlVXJsPVwiICsgZW5jb2RlVVJJKHRoaXMucGF0aG5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLmhyZWYgPSBuZXdEb2NVcmw7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcblNQLlNPRC5leGVjdXRlRnVuYygnc3AuanMnLCAnU1AuQ2xpZW50Q29udGV4dCcsIGNoZWNrSWZVc2VySXNBdXRoZW50aWNhdGVkKTtcclxuXHJcbmZ1bmN0aW9uIGNoZWNrSWZVc2VySXNBdXRoZW50aWNhdGVkKCkge1xyXG4gICAgY2xpZW50Q29udGV4dCA9IFNQLkNsaWVudENvbnRleHQuZ2V0X2N1cnJlbnQoKTtcclxuICAgIHdlYnNpdGUgPSBjbGllbnRDb250ZXh0LmdldF93ZWIoKTtcclxuICAgIHVzZXIgPSB3ZWJzaXRlLmdldF9jdXJyZW50VXNlcigpO1xyXG5cclxuICAgIGNsaWVudENvbnRleHQubG9hZCh1c2VyKTtcclxuICAgIGNsaWVudENvbnRleHQuZXhlY3V0ZVF1ZXJ5QXN5bmMoXHJcbiAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBVc2VyIGlzIGF1dGhlbnRpY2F0ZWQuIERvIG5vdGhpbmcuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0ludGVybmV0RXhwbG9yZXIoKSkge1xyXG4gICAgICAgICAgICAgICAgcmVwbGFjZURvd25sb2FkTGlua3MoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAkKGRvY3VtZW50KS5hamF4U3RvcChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZURvd25sb2FkTGlua3MoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbn1cclxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIlZDbUVzd1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2Rvd25sb2FkT2ZmaWNlRG9jdW1lbnRzLmpzXCIsXCIvXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xyXG5cdHJlcXVpcmUoJy4vZm9sZGFibGVDb250ZW50LmpzJyk7XHJcblxyXG5cdHJlcXVpcmUoJy4vbWFpbk1lbnUuanMnKTtcclxuXHJcblx0cmVxdWlyZSgnLi90b2dnbGVBcnJvd0Z1bmN0aW9uLmpzJyk7XHJcblxyXG5cdHJlcXVpcmUoJy4vZm9vdGVyVGFicy5qcycpO1xyXG5cclxuXHRyZXF1aXJlKCcuL3NoYXJlRnVuY3Rpb24uanMnKTtcclxuXHJcblx0cmVxdWlyZSgnLi9ndWlkZXNGdW5jdGlvbi5qcycpO1xyXG5cclxuXHRyZXF1aXJlKCcuL3NoYXJlUG9pbnRVdGlsaXRpZXMuanMnKTtcclxuXHJcblx0cmVxdWlyZSgnLi9hZGRFeHRlcm5hbGljb25GdW5jdGlvbi5qcycpO1xyXG5cclxuXHRyZXF1aXJlKCcuL3Rvb2x0aXAuanMnKTtcclxuXHJcblx0cmVxdWlyZSgnLi9jb29raWUuanMnKTtcclxuXHRcclxuXHRyZXF1aXJlKCcuL3ByaW50RnVuY3Rpb24uanMnKTtcclxuXHJcblx0cmVxdWlyZSgnLi9kb3dubG9hZE9mZmljZURvY3VtZW50cy5qcycpO1xyXG5cclxuXHRyZXF1aXJlKCcuL25ld3NMZXR0ZXJEaWFsb2cuanMnKTtcclxuXHJcblx0Ly8gTkxIIDIwMTUtMTEtMDQgKyBIZWxwZXIgZnVuY3Rpb25zIGxpa2UgY29weSB0byBjbGlwYm9hcmQsIHRvZ2dsZSB0ZWNobmljYWwgaW5mbyBtZXNzYWdlcyBzaG93ZWQgbGlrZSBjb29raWUgbWVzc2FnZSwgZXRjLiBcclxuXHRyZXF1aXJlKCcuL2hlbHBlckZ1bmN0aW9ucy5qcycpO1xyXG5cclxufSk7XHJcblxyXG4kKHdpbmRvdykubG9hZChmdW5jdGlvbiAoKSB7XHJcblx0cmVxdWlyZSgnLi9ncmlkR2FsbGVyeVNpemVGdW5jdGlvbi5qcycpO1xyXG5cclxuXHRyZXF1aXJlKCcuL3Nob3dBbGxSZWZpbmVyLmpzJyk7XHJcblxyXG5cdCQuZ2V0U2NyaXB0KCcvX2xheW91dHMvMTUvU2NyaXB0UmVzeC5hc2h4P25hbWU9RnZzdFJlc291cmNlJmN1bHR1cmU9JyArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nKVxyXG4gICAgIC5kb25lKGZ1bmN0aW9uICgpIHsgXHJcbiAgICAgXHRGVlNUID0ge307IFxyXG4gICAgIFx0RlZTVC5SZXMgPSBSZXM7XHJcbiAgICAgfSlcclxuICAgICAuZmFpbChmdW5jdGlvbiAoKSB7IFxyXG4gICAgIFx0Y29uc29sZS5sb2coXCJlcnJvclwiKTsgXHJcbiAgICAgfSk7XHJcbn0pO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJWQ21Fc3dcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9mYWtlX2NkNTgwMmU4LmpzXCIsXCIvXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8qKkZPUiBORVcgU1AyMDEzIENPREUqKi8vXHJcbi8vbW1jQG5ldGNvbXBhbnkuY29tIC0gSlMgRlVOQ1RJT04gRk9SIEFDQ09SRElPTiBDT05URU5UIFRZUE9HUkFQSFkgTUVOVVMgLSAxMy0xMS0yMDE0XHJcblxyXG52YXIgbG9jYWxpemVkU2hvd01vcmVUZXh0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgPT0gJ2RhLURLJyA/IFwiVmlzIGFsbGVcIiA6IFwiU2hvdyBhbGxcIjtcclxudmFyIGxvY2FsaXplZFNob3dMZXNzVGV4dCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nID09ICdkYS1ESycgPyBcIlNranVsIGFsbGVcIiA6IFwiSGlkZSBhbGxcIjtcclxuXHJcbi8vSEFDSyBGT1IgU0hPV0lORyBNT1JFIERJVlMgQUZURVIgVE9HR0xFIEJPWEVTXHJcblxyXG4vL01BS0UgT0xEIENPTlRFTlQgRk9MREFCTEVcclxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGluVmlld01vZGUgPSAwO1xyXG4gICAgaWYgKHR5cGVvZiAoUGFnZVN0YXRlKSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBpblZpZXdNb2RlID0gMTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICh0eXBlb2YgKFBhZ2VTdGF0ZS5WaWV3TW9kZUlzRWRpdCkgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGluVmlld01vZGUgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFQYWdlU3RhdGUuVmlld01vZGVJc0VkaXQpIHtcclxuICAgICAgICAgICAgICAgIGluVmlld01vZGUgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoJCgnI2ZvbGRBbmNob3InKS5sZW5ndGggPT09IDAgJiYgaW5WaWV3TW9kZSkge1xyXG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSAkKCdkaXYubXMtcnRlRWxlbWVudC1Gb2xkSGVhZGluZycpO1xyXG5cclxuICAgICAgICAvL0NyZWF0ZSBhbmNob3IsIHNvIHdlIGtub3cgd2hlcmUgd2Ugc3RhcnRlZCwgYmVmb3JlIG1lc3NpbmcgdXAgdGhlIERPTVxyXG4gICAgICAgIHNlbGVjdGlvbi5maXJzdCgpLmJlZm9yZSgnPGRpdiBpZD1cImZvbGRBbmNob3JcIiAvPicpO1xyXG5cclxuICAgICAgICBmb2xkRml4VXAoc2VsZWN0aW9uLCAkKCcjZm9sZEFuY2hvcicpKTtcclxuXHJcbiAgICAgICAgLy9SZW1vdmUgb2xkIG9ic29sZXRlIGNsYXNzXHJcbiAgICAgICAgJChcIkRJVi5tcy1ydGVFbGVtZW50LUZvbGRDb250ZW50XCIpLnJlbW92ZUNsYXNzKFwibXMtcnRlRWxlbWVudC1Gb2xkQ29udGVudFwiKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5cclxudmFyIGZvbGRGaXhVcCA9IGZ1bmN0aW9uIChoZWFkaW5ncywgYmFzZUVsZW0pIHtcclxuXHJcbiAgICBoZWFkaW5ncy5lYWNoKGZ1bmN0aW9uIChpbmRleCwgZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBteUVsZW0sIGNvbnRlbnQsIGNvbnRlbnRBZnRlciwgZm9sZEVsZW1lbnQsIHM7XHJcblxyXG4gICAgICAgIG15RWxlbSA9ICQoZWxlbWVudCk7XHJcblxyXG4gICAgICAgIHMgPSBteUVsZW0uaHRtbCgpO1xyXG4gICAgICAgIG15RWxlbS5odG1sKCc8YSBocmVmPVwiI1wiPicgKyBzICsgJzwvYT4nKTtcclxuXHJcbiAgICAgICAgLy9yZW1vdmUgZnJvbSB0aGUgRE9NIHRoZSBkaXZzIGJlbG9uZ2luZyB0byB0aGlzIGhlYWRpbmcuXHJcbiAgICAgICAgY29udGVudCA9IG15RWxlbS5uZXh0VW50aWwoXCJkaXYubXMtcnRlRWxlbWVudC1Gb2xkSGVhZGluZzpmaXJzdFwiKS5kZXRhY2goKTsgLy8gZGl2Om5vdCgnLmZ2c3QtcnRlRWxlbWVudC1ESVYtSlNGb2xkJylcIik7IHRvIHRlc3QgZm9yIGFzLWxvbmctYXMuIEJ1dCBTaGFyZVBvaW50IG1pZ2h0IGluc2VydCBleHRyYSBlbXB0eSBESVZzIHdoaWNoIHdpbGwgYnJlYWsgdGhlIHNjcmlwdCBmdW5jdGlvblxyXG4gICAgICAgIGNvbnRlbnRBZnRlciA9IG15RWxlbS5wYXJlbnQoKS5uZXh0VW50aWwoXCJkaXYubXMtcnRlRWxlbWVudC1Gb2xkSGVhZGluZzpmaXJzdFwiKS5kZXRhY2goKTtcclxuXHJcbiAgICAgICAgLy9DcmVhdGUgbmV3IGRpdiwgYW5kIGF0dGFjaCB0aGUgcHJldmlvdXMgZGV0YWNoZWQncyBkaXZzIGluc2lkZSBpdFxyXG4gICAgICAgIGZvbGRFbGVtZW50ID0gJCgnPGRpdiBjbGFzcz1cImZha2UtZm9sZCBmYWtlLWZvbGQtY2xvc2VkXCIgLz4nKTtcclxuICAgICAgICBmb2xkRWxlbWVudCA9IGZvbGRFbGVtZW50LmFwcGVuZChjb250ZW50KTtcclxuICAgICAgICBmb2xkRWxlbWVudCA9IGZvbGRFbGVtZW50LmFwcGVuZChjb250ZW50QWZ0ZXIpO1xyXG5cclxuICAgICAgICAvL21vdmUgdGhlIGN1cnJlbnQgaGVhZGxpbmVcclxuICAgICAgICBiYXNlRWxlbS5hZnRlcihteUVsZW0pO1xyXG4gICAgICAgIC8vYXR0YWNoIHRoZSBuZXdseSBjcmVhdGVkIGVsZW1lbnQgYWZ0ZXIgdGhlIGhlYWRpbmcuXHJcbiAgICAgICAgYmFzZUVsZW0ubmV4dCgpLmFmdGVyKGZvbGRFbGVtZW50KTtcclxuICAgICAgICBiYXNlRWxlbSA9IGJhc2VFbGVtLm5leHQoKS5uZXh0KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZigkKCcjZm9sZEFuY2hvcicpLmxlbmd0aCl7XHJcbiAgICAgICAgd2VicGFydHMgPSAkKFwiLm1zLXdlYnBhcnQtem9uZVwiKS5kZXRhY2goKTtcclxuICAgIH1cclxuXHJcbiAgICAvL0FERElORyBTSE9XL0hJREUgQlVUVE9OUyBUT1BcclxuICAgICQoXCIubXMtcnRlRWxlbWVudC1Gb2xkSGVhZGluZ1wiKS5maXJzdCgpLmJlZm9yZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuXCI8ZGl2IGNsYXNzPSdidG5fZ3JvdXAnPlwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIjxkaXYgaWQ9J3Nob3cxJz5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgXCI8c3BhbiBjbGFzcz0nZmEtc3RhY2sgdG9nZ2xlJz5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxpIGNsYXNzPSdmYS1saSBmYSBmYS1jaXJjbGUtdGhpbic+PC9pPlwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPGkgY2xhc3M9J2ZhLWxpIGZhIGZhLWFuZ2xlLWRvd24nPjwvaT5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiPC9zcGFuPlwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCI8bGkgY2xhc3M9J2xlZnQtYm9yZGVyJz5cIiArIGxvY2FsaXplZFNob3dNb3JlVGV4dCArIFwiPC9saT5cIiArICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiPGxpIGNsYXNzPSdzZXBlcmF0b3InPnw8L2xpPlwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIjwvZGl2PlwiICtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBcIjxkaXYgaWQ9J2hpZGUxJz5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiPHNwYW4gY2xhc3M9J2ZhLXN0YWNrIHRvZ2dsZSc+XCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI8aSBjbGFzcz0nZmEtbGkgZmEgZmEtY2lyY2xlLXRoaW4nPjwvaT5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxpIGNsYXNzPSdmYS1saSBmYSBmYS1hbmdsZS11cCc+PC9pPlwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCI8L3NwYW4+XCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIjxsaSBjbGFzcz0nbGVmdC1ib3JkZXInPlwiICsgbG9jYWxpemVkU2hvd0xlc3NUZXh0ICsgXCI8L2xpPiBcIiArICBcclxuICAgICAgICAgICAgICAgICAgICBcIjwvZGl2PlwiICtcclxuICAgICAgICAgICAgICAgXCI8L2Rpdj5cIjtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vQURESU5HIFNIT1cvSElERSBCVVRUT05TIEJPVFRPTVxyXG4gICAgJCgnLmZha2UtZm9sZDpsYXN0JykuYWZ0ZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVyblwiPGRpdiBjbGFzcz0nYnRuX2dyb3VwJz4gXCIrXHJcbiAgICAgICAgICAgICAgICAgIFwiPGRpdiBpZD0nc2hvdzInPlwiICtcclxuICAgICAgICAgICAgICAgICAgICAgXCI8c3BhbiBjbGFzcz0nZmEtc3RhY2sgdG9nZ2xlJz5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiPGkgY2xhc3M9J2ZhLWxpIGZhIGZhLWNpcmNsZS10aGluJz48L2k+XCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCI8aSBjbGFzcz0nZmEtbGkgZmEgZmEtYW5nbGUtZG93bic+PC9pPlwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIjwvc3Bhbj5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIjxsaSBjbGFzcz0nbGVmdC1ib3JkZXInPlwiICsgbG9jYWxpemVkU2hvd01vcmVUZXh0ICsgXCI8L2xpPiAgIFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICBcIjxsaSBjbGFzcz0nc2VwZXJhdG9yJz58PC9saT5cIiArXHJcbiAgICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICBcIjxkaXYgaWQ9J2hpZGUyJz5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgIFwiPHNwYW4gY2xhc3M9J2ZhLXN0YWNrIHRvZ2dsZSc+XCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIjxpIGNsYXNzPSdmYS1saSBmYSBmYS1jaXJjbGUtdGhpbic+PC9pPlwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxpIGNsYXNzPSdmYS1saSBmYSBmYS1hbmdsZS11cCc+PC9pPlwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCI8L3NwYW4+XCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIjxsaSBjbGFzcz0nbGVmdC1ib3JkZXInPlwiICsgbG9jYWxpemVkU2hvd0xlc3NUZXh0ICsgXCI8L2xpPiBcIiArICBcclxuICAgICAgICAgICAgICAgICBcIjwvZGl2PlwiICtcclxuICAgICAgICAgICAgXCI8L2Rpdj5cIjtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vQUREIFdFQlBBUlRTXHJcbiAgICBpZigkKCcjZm9sZEFuY2hvcicpLmxlbmd0aCl7XHJcbiAgICAgICAgJCgnLmJ0bl9ncm91cDpsYXN0JykuYWZ0ZXIod2VicGFydHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vQ0xJQ0sgRlVOQ1RJT04gRk9SIFRPR0dMSU5HIENPTlRFTlQgQU5EIFRPT0dMRSBCRVRXRUVOIElDT05TXHJcbiAgICAkKFwiLm1zLXJ0ZUVsZW1lbnQtRm9sZEhlYWRpbmdcIikuY2xpY2soZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGVsZW0gPSAkKHRoaXMpO1xyXG5cclxuICAgICAgICAkKHRoaXMpLm5leHQoKS5zbGlkZVRvZ2dsZSgnc2xvdycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoJCh0aGlzKS5pcygnOnZpc2libGUnKSkge1xyXG4gICAgICAgICAgICAgICAgJChlbGVtKS5jc3MoXCJiYWNrZ3JvdW5kLWltYWdlXCIsIFwidXJsKC9fbGF5b3V0cy8xNS9OZXRjb21wYW55LkZWUzAwMDEvaW1hZ2VzL21pbnVzaWNvbi5wbmcpXCIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgJChlbGVtKS5jc3MoXCJiYWNrZ3JvdW5kLWltYWdlXCIsIFwidXJsKC9fbGF5b3V0cy8xNS9OZXRjb21wYW55LkZWUzAwMDEvaW1hZ2VzL3BsdXNpY29uLnBuZylcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvL0NMSUsgRlVDTlRJT04gRk9SIFNIT1cgT1IgSElERSBBTExcclxuICAgICQoXCIjc2hvdzEsI3Nob3cyXCIpLmNsaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAkKFwiLmZha2UtZm9sZFwiKS5zaG93KCdmYXN0Jyk7XHJcbiAgICAgICAgJChcIi5tcy1ydGVFbGVtZW50LUZvbGRIZWFkaW5nXCIpLmNzcyhcImJhY2tncm91bmQtaW1hZ2VcIiwgXCJ1cmwoL19sYXlvdXRzLzE1L05ldGNvbXBhbnkuRlZTMDAwMS9pbWFnZXMvbWludXNpY29uLnBuZylcIik7XHJcbiAgICB9KTtcclxuICAgICQoXCIjaGlkZTEsI2hpZGUyXCIpLmNsaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAkKFwiLmZha2UtZm9sZFwiKS5oaWRlKCdmYXN0Jyk7XHJcbiAgICAgICAgJChcIi5tcy1ydGVFbGVtZW50LUZvbGRIZWFkaW5nXCIpLmNzcyhcImJhY2tncm91bmQtaW1hZ2VcIiwgXCJ1cmwoL19sYXlvdXRzLzE1L05ldGNvbXBhbnkuRlZTMDAwMS9pbWFnZXMvcGx1c2ljb24ucG5nKVwiKTtcclxuICAgIH0pO1xyXG5cclxufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiVkNtRXN3XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvZm9sZGFibGVDb250ZW50LmpzXCIsXCIvXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8qKkZPUiBORVcgU1AyMDEzIENPREUqKi8vXHJcbi8vbW1jQG5ldGNvbXBhbnkuY29tIC0gSlMgRlVOQ1RJT04gRk9SIE1BSU4gTUVOVSBJQ09OUyAtIDIwLTExLTIwMTRcclxuLy9UTyBGSU5EIFRIRSBDTElDS0VEIEZPT1RFUlRBQi1JVEVNIEFORCBUTyBISUdITElHSFQgVEhFIE9ORSBUSEFUUyBDTElDS0VELlxyXG5cclxuLy9NQUtFIFRIRSBGSVJTVCBUQUIgQ0hFQ0tFRCBBTkQgTUFLRSBJVCBBQ1RJVkUuXHJcbiQoXCIudGFicyBsaSBpbnB1dFwiKS5maXJzdCgpLmF0dHIoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xyXG4kKFwiLnRhYnMgbGkgbGFiZWxcIikuZmlyc3QoKS5hZGRDbGFzcygnYWN0aXZlJyk7XHJcblxyXG4vL0NIRUNLIElGIEFOWSBUQUIgSVMgQUNUSVZFIEFORCBSRU1PVkUgQUNUSVZFIENMQVNTXHJcbiQoXCIudGFicyBsaSBsYWJlbFwiKS5jbGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICBpZigkKCcudGFicyBsaSBsYWJlbCcpLmhhc0NsYXNzKCdhY3RpdmUnKSl7XHJcbiAgICAgICAgJCgnLnRhYnMgbGkgbGFiZWwnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLy9NQUtFIENMSUNLRUQgVEFCIEFDVElWRVxyXG4kKFwiLnRhYnMgbGkgbGFiZWxcIikuY2xpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG59KTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiVkNtRXN3XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvZm9vdGVyVGFicy5qc1wiLFwiL1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vKipGT1IgTkVXIFNQMjAxMyBDT0RFKiovL1xyXG4vL21tY0BuZXRjb21wYW55LmNvbSAtIEZVTkNUSU9OIFRPIE1BS0UgRElWUyBVTkRFUiBJTUcgSU4gR1JJREdBTExFUlkgVE8gQkUgU0FNRSBTSVpFLSAxLTEyLTIwMTRcclxuXHJcbi8vQUREIENMQVNTIFRPIEZPVU5EIERJVlxyXG52YXIgYWRkR3JpZEl0ZW1QYXJhZ3JhcGhDbGFzcyA9IGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50LCBwYXJhZ3JhcGhOYW1lKSB7XHJcbiAgICAkKGVsZW1lbnQpLmFkZENsYXNzKHBhcmFncmFwaE5hbWUgKyBpbmRleCk7XHJcbn07XHJcblxyXG4vL0dFVCBUSEUgQklHR0VTVCBESVYgQU5EIFNFVCBESVYgV0lUSCBTQU1FIElEIFRPIFRIRSBCSUdHRVNUIFNJWkVcclxuLy92YXIgaSA9IDE7XHJcbiQoXCIjY29sLWxlZnRcIikuZmluZCgnLmdyaWRfaXRlbScpLmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQpIHtcclxuXHRhZGRHcmlkSXRlbVBhcmFncmFwaENsYXNzKGluZGV4LCBlbGVtZW50LCAnbGVmdF9wYXJhZ3JhcGhfJyk7XHJcbn0pO1xyXG5cclxuJChcIiNjb2wtcmlnaHRcIikuZmluZCgnLmdyaWRfaXRlbScpLmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQpIHtcclxuXHRhZGRHcmlkSXRlbVBhcmFncmFwaENsYXNzKGluZGV4LCBlbGVtZW50LCAncmlnaHRfcGFyYWdyYXBoXycpO1xyXG59KTtcclxuXHJcbiQoXCIuZ3JpZGdhbGxlcnktbGlzdC1pdGVtXCIpLmVhY2goZnVuY3Rpb24oaW5kZXgpIHtcclxuXHR2YXIgbGVmdF9wYXJhZ3JhcGggPSAkKCcubGVmdF9wYXJhZ3JhcGhfJyArIGluZGV4KTtcclxuXHR2YXIgcmlnaHRfcGFyYWdyYXBoID0gICQoJy5yaWdodF9wYXJhZ3JhcGhfJyArIGluZGV4KTtcclxuXHJcblx0dmFyIGxlZnRfcGFyYWdyYXBoX2hlaWdodCA9IGxlZnRfcGFyYWdyYXBoLmhlaWdodCgpO1xyXG5cdHZhciByaWdodF9wYXJhZ3JhcGhfaGVpZ2h0ID0gIHJpZ2h0X3BhcmFncmFwaC5oZWlnaHQoKTtcclxuXHJcblx0aWYobGVmdF9wYXJhZ3JhcGhfaGVpZ2h0ID4gcmlnaHRfcGFyYWdyYXBoX2hlaWdodCkge1xyXG4gIFx0XHRyaWdodF9wYXJhZ3JhcGguY3NzKCdoZWlnaHQnLCBsZWZ0X3BhcmFncmFwaF9oZWlnaHQgKyAncHgnKTtcdCAgXHRcdFxyXG5cdH0gZWxzZSB7XHJcbiAgXHRcdGxlZnRfcGFyYWdyYXBoLmNzcygnaGVpZ2h0JywgcmlnaHRfcGFyYWdyYXBoX2hlaWdodCArICdweCcpO1xyXG5cdH1cclxufSk7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcIlZDbUVzd1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2dyaWRHYWxsZXJ5U2l6ZUZ1bmN0aW9uLmpzXCIsXCIvXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8qKkZPUiBORVcgU1AyMDEzIENPREUqKi8vXHJcbi8vbW1jQG5ldGNvbXBhbnkuY29tIC0gSlMgRlVOQ1RJT04gR1VJREVTIEZPTERJTi9GT0xET1VULSAyNS0xMS0yMDE0XHJcblxyXG4vL0pTIEZPUiBHVUlERVMgRk9MRElOL0ZPTERPVVQgLSAoRk9SIFBBR0VTIFdJVEggQUpBWCBDQUxMKVxyXG4vL1RPIE1BS0UgVEhJUyBSRU5ERVIgT04gV0lORE9XIExPQUQgTk9UIE9OIERPQ1VNRU5UIFJFQURZLihHbG9iYWwgRnVuY3Rpb24pXHJcblxyXG4vL1dFIEhBVkUgVE8gSU1QT1JUIFxyXG5cdC8vR3VpZGVWMi5qcyBpbiBoZXJlIGFuZCBjbGVhbnVwIGFuZCBzdHJ1Y3R1ciBqcyBpbiB0aGUgZmlsZS4gIFxyXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiVkNtRXN3XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvZ3VpZGVzRnVuY3Rpb24uanNcIixcIi9cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vKiBcclxuXHRDb3B5IGRhdGEgdG8gY2xpcGJvYXJkIHdpdGhvdXQgdXNpbmcgRmxhc2ggKHNlZSBodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1jbGlwYm9hcmQpIFxyXG5cdElFOSwgSUUxMCBhbmQgSUUxMSBzdXBwb3J0cyBjbGlwYm9hcmREYXRhIHdlcmUgdXNlciBncmFudHMgYWNjZXNzLiBGb3Igb3RoZXIgYnJvd3NlciB3ZSBzaG93IHByb21wdCwgd2VyZSB1c2VyIGNhbiBjb3B5IHRoZSBkYXRhIHdpdGggQ3RybCtDIHNob3J0Y3V0IGtleVxyXG4qL1xyXG5mdW5jdGlvbiBjb3B5VG9DbGlwYm9hcmQoZWxlbWVudCxjb3B5VGV4dCkge1xyXG5cdCQoZWxlbWVudCkuc2VsZWN0KCk7XHQgXHJcblx0dmFyIHRleHQgPSAkKGVsZW1lbnQpLnZhbCgpO1xyXG5cdGlmIChjb3B5VGV4dCkgdGV4dCA9ICQoZWxlbWVudCkudGV4dCgpO1xyXG5cdHRyeSB7XHJcblx0XHRpZiggd2luZG93LmNsaXBib2FyZERhdGEgJiYgY2xpcGJvYXJkRGF0YS5zZXREYXRhICl7IFxyXG5cdFx0XHR3aW5kb3cuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwiVGV4dFwiLCB0ZXh0KTsgXHJcblx0XHR9IFxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdC8vIElmIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgY29weSBhY3Rpb24gZXhjZXB0aW9uIGlzIHRocm93biBhbmQgZGVmYXVsdCBiZWhhdmlvciB1c2VkXHJcblx0XHRcdGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiY29weVwiKTtcclxuXHRcdH1cclxuXHR9XHJcblx0Y2F0Y2goZSkge1xyXG5cdFx0Ly8gRGVmYXVsdCB0aGF0IHdvcmtzIGluIGFsbCBicm93c2Vyc1xyXG5cdFx0d2luZG93LnByb21wdChcIkN0cmwrQ1wiLCB0ZXh0KTtcclxuXHR9IFxyXG59XHJcblxyXG4vLyBHbG9iYWwgbWVzc2FnZSBpZiBzaG93biBldmVyeXRpbWUgdXNlciByZWZyZXNoZXMgdGhlIHBhZ2UsIGlmIG1vcmUgdGhhbiAzMCBtaW51dGVzIGhhcyBlbGFwc2VkIHNpbmNlIGxhc3QgdGltZSBpdCB3YXMgZGlzcGxheWVkIFxyXG5mdW5jdGlvbiBzaG93R2xvYmFsTWVzc2FnZSgpIHtcclxuXHJcblx0Ly8gSWYgbm90IFRlY2huaWNhbFN0YXR1c19WaXNpYmxlPTAgaWYgU2hhcmVQb2ludCBiYWNrZW5kIGxpc3QsIHRoZW4gdGVjaG5pY2FsIHN0YXR1cyBtZXNzYWdlcyBhcmUgZGlzYWJsZWQgYWxsIHRvZ2V0aGVyXHJcblx0aWYgKCEkKCcjZ2xvYmFsX21lc3NhZ2UnKS5oYXNDbGFzcyhcImdsb2JhbF9tZXNzYWdlX2hpZGVcIikpIHsgXHJcblx0XHQkKCcjZ2xvYmFsX21lc3NhZ2VfY2xvc2VfYnRuJykuY2xpY2soZnVuY3Rpb24oZSl7XHJcblx0XHRcdC8vJCgnI2dsb2JhbF9tZXNzYWdlJykuaGlkZSgpO1xyXG5cdFx0XHQvLyQoJyNzNC13b3Jrc3BhY2UnKS5jc3MoXCJoZWlnaHRcIixcIjEwMCVcIik7XHJcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcblx0XHRcdHZhciBkYXRlID0gbmV3IERhdGUoKTtcclxuXHRcdFx0dmFyIG1pbnV0ZXMgPSAkKCcjY3RsMDBfY3RsNDVfR2xvYmFsTWVzc2FnZUNvb2tpZVRpbWVvdXQnKS52YWwoKTtcclxuXHQgXHRcdGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIChtaW51dGVzICogNjAgKiAxMDAwKSk7XHJcblx0IFx0XHR2YXIgdGltZXN0YW1wID0gJCgnI2N0bDAwX2N0bDQ1X0dsb2JhbE1lc3NhZ2VUaW1lc3RhbXAnKS52YWwoKTtcclxuXHRcdFx0JC5jb29raWUoJ2dsb2JhbE1lc3NhZ2VDbG9zZWQnLCB0aW1lc3RhbXAsIHtleHBpcmVzOiBkYXRlLCBwYXRoOiAnLycgfSk7XHJcblx0XHRcdGxvY2F0aW9uLnJlbG9hZChmYWxzZSk7XHJcblx0XHR9KTtcclxuXHRcdC8vIENoZWNrIGlmIHVzZXIgYWxyZWFkeSBjbG9zZWQgZ2xvYmFsIG1lc3NhZ2UgdG9kYXkgb3IgaWYgdXNlciBjb250cm9sIGFkZGVkIGhpZGUgY3NzIGNsYXNzIHRvIGluZGljYXRlIGdsb2JhbCBtZXNzYWdlIHdhcyBkaXNhYmxlZCBzZXJ2ZXIgc2lkZVxyXG5cdFx0dmFyIHRpbWVzdGFtcCA9ICQoXCIjY3RsMDBfY3RsNDVfR2xvYmFsTWVzc2FnZVRpbWVzdGFtcFwiKS52YWwoKTtcclxuXHJcblx0XHQvL2NvbnNvbGUubG9nKCdnbG9iYWxNZXNzYWdlQ2xvc2VkOiAnKyQuY29va2llKCdnbG9iYWxNZXNzYWdlQ2xvc2VkJykrJyE9PScrdGltZXN0YW1wKTtcclxuXHRcdGlmKCQuY29va2llKCdnbG9iYWxNZXNzYWdlQ2xvc2VkJykgIT09IHRpbWVzdGFtcCkge1xyXG5cdFx0XHQkKCcjZ2xvYmFsX21lc3NhZ2UnKS5zaG93KCk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vKiBBZGQgc3BlZWNoIGJ1YmJsZSBhZnRlciBzZWFyY2ggcmVzdWx0IGlzIGxvYWRlZFxyXG5cdHBhcmVudFNlbGVjdG9yOiBcdFVzZSBqUXVlcnkgc2VsZWN0b3IgdG8gZmluZCBwYXJlbnQgb2Ygc3BlZWNoIGJ1YmxlIFwiLnNlYXJjaF9yb3dfaXRlbSB0aDpsYXN0LWNoaWxkXCJcclxuXHRpZDogXHRcdFx0XHRBbnkgaWQgbGlrZSBcIm15YnViYmxlXCJcclxuXHRodG1sOiBcdFx0XHRcdEdpdmUgc29tIEhUTUwgdGV4dCBmb3IgdGhlIFAgdGFnIGxpa2UgXCJIZWxsbyB3b3JsZCFcIlxyXG5cdGNsYXNzTmFtZTogXHRcdFx0QXBwbHkgY2xhc3MgcG9zMCwgcG9zMSwgcG9zMiwgcG9zMywgcG9zNCB0byBwb3NpdGlvbiBvZiBzcGVlY2ggYnViYmxlIHRvcCB0cmlhbmdsZSAgXHJcbmZ1bmN0aW9uIHNob3dTcGVlY2hCdWJibGUocGFyZW50U2VsZWN0b3IsaWQsaHRtbCxjbGFzc05hbWUpIHtcclxuXHR2YXIgcG9zID0gXCJwb3MwXCI7XHJcblx0aWYgKGNsYXNzTmFtZSkgcG9zID0gY2xhc3NOYW1lO1xyXG5cdCQocGFyZW50U2VsZWN0b3IpLmFwcGVuZCgnPHAgY2xhc3M9XCJ0cmlhZ2xlLXRvcC1zcGFjZXJcIj48L3A+Jyk7XHJcblx0JChwYXJlbnRTZWxlY3RvcikuYXBwZW5kKCc8cCBpZD1cIicraWQrJ1wiY2xhc3M9XCJ0cmlhbmdsZS1ib3JkZXIgdG9wICcrcG9zKydcIj4nK2h0bWwrJzwvcD4nKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2hvd1NlYXJjaFJlc3VsdFNwZWVjaEJ1YmJsZShlbGVtZW50KSB7XHJcblx0dmFyIHRyID0gJChlbGVtZW50KS5wYXJlbnRzKFwiLnNlYXJjaF9yb3dfaXRlbVwiKS5uZXh0KFwiLnNlYXJjaF9yb3dfaW5mb1wiKTtcclxuXHRpZiAodHIpIHtcclxuXHRcdHRyLmNzcyhcImRpc3BsYXlcIixcInRhYmxlLXJvd1wiKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhpZGVTZWFyY2hSZXN1bHRTcGVlY2hCdWJibGUoZWxlbWVudCkge1xyXG5cdCQoZWxlbWVudCkucGFyZW50KFwiLnNlYXJjaF9yb3dfaW5mb1wiKS5oaWRlKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRvZ2dsZVNlYXJjaFJlc3VsdFNwZWVjaEJ1YmJsZShlbGVtZW50LGV2ZW50KSB7XHJcblx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHR2YXIgdHIgPSAkKGVsZW1lbnQpLnBhcmVudHMoXCIuc2VhcmNoX3Jvd19pdGVtXCIpLm5leHQoXCIuc2VhcmNoX3Jvd19pbmZvXCIpO1xyXG5cdGlmICh0cikge1xyXG5cdFx0aWYgKHRyLmNzcyhcImRpc3BsYXlcIikgPT09IFwibm9uZVwiKSB7XHJcblx0XHRcdHRyLmNzcyhcImRpc3BsYXlcIixcInRhYmxlLXJvd1wiKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR0ci5oaWRlKCk7XHRcdFx0XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuKi9cclxuXHJcbihmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpe1xyXG4gICAgd2luZG93LmNvcHlUb0NsaXBib2FyZCA9IGNvcHlUb0NsaXBib2FyZDtcclxuICAgIHdpbmRvdy5zaG93R2xvYmFsTWVzc2FnZSA9IHNob3dHbG9iYWxNZXNzYWdlO1xyXG4gICAgLyp3aW5kb3cuc2hvd1NwZWVjaEJ1YmJsZSA9IHNob3dTcGVlY2hCdWJibGU7XHJcbiAgICB3aW5kb3cuc2hvd1NlYXJjaFJlc3VsdFNwZWVjaEJ1YmJsZSA9IHNob3dTZWFyY2hSZXN1bHRTcGVlY2hCdWJibGU7XHJcbiAgICB3aW5kb3cuaGlkZVNlYXJjaFJlc3VsdFNwZWVjaEJ1YmJsZSA9IGhpZGVTZWFyY2hSZXN1bHRTcGVlY2hCdWJibGU7XHJcbiAgICB3aW5kb3cudG9nZ2xlU2VhcmNoUmVzdWx0U3BlZWNoQnViYmxlID0gdG9nZ2xlU2VhcmNoUmVzdWx0U3BlZWNoQnViYmxlOyovXHJcbn0pKHdpbmRvdywgZG9jdW1lbnQpO1xyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9ucyBhcmUgY2FsbGVkIG9uIGRvY3VtZW50LnJlYWR5IGluIG1haW4uanNcclxuc2hvd0dsb2JhbE1lc3NhZ2UoKTtcclxuXHJcbi8vVGVzdCBzcGVlY2ggYnViYmxlIGFmdGVyIGFueSBlbGVtZW50XHJcbi8vc2hvd1NwZWVjaEJ1YmJsZShcIi5zZWFyY2hfcm93X2l0ZW0gdGg6bGFzdC1jaGlsZFwiLFwibXlidWJibGVcIixcIkhlbGxvIHdvcmxkIVwiLFwicG9zNFwiKTsgXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIlZDbUVzd1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2hlbHBlckZ1bmN0aW9ucy5qc1wiLFwiL1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vKipGT1IgTkVXIFNQMjAxMyBDT0RFKiovL1xyXG4vL21tY0BuZXRjb21wYW55LmNvbSAtIEpTIEZVTkNUSU9OIEZPUiBNQUlOIE1FTlUgLSAxOS0xMS0yMDE0XHJcblxyXG4vL1RPIEZJTkQgVEhFIENMSUNLRUQgTUVOVS1JVEVNIEFORCBUTyBERUZBVUxUIFRPR0dMRSBBTEwgSUNPTlMgRE9XTiBFWENFUFQgVEhFIE9ORSBUSEFUUyBDTElDS0VELlxyXG4kKCcubWFpbi1tZW51JykuY2xpY2soZnVuY3Rpb24oKXtcclxuICAgICQoJy5tYWluLW1lbnUnKS5maW5kKCdpJykuYXR0ciggXCJjbGFzc1wiLCBcImZhIGZhLWNoZXZyb24tZG93blwiICk7XHJcbiAgICAkKHRoaXMpLmZpbmQoJ2knKS5hdHRyKCBcImNsYXNzXCIsIFwiZmEgZmEtY2hldnJvbi11cFwiICk7XHJcbn0pO1xyXG5cclxuXHJcbi8vIE9OIFNFQVJDSC5BU1BYIFNFQVJDSCBCT1ggV0lMTCBBTFdBWVMgU0hPVyBBTkQgRk9DVVNcclxuLy8gTUVOVS1JVEVNIEFORCBTRUFSQ0gtUFJPRkVTU0lPTiBXSUxMIEJPVEggU0hPVyBBTkQgSElERSBDTElDS0VEXHJcbmlmICh3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKFwiU2VhcmNoLmFzcHhcIikgIT0gLTEpIHtcclxuICAgICQoJyNzZWFyY2gtdG9nZ2xlLWJ0bicpLnByb3AoJ2NoZWNrZWQnLCB0cnVlKTsgIFxyXG4gICAgJCgnLnNlYXJjaF9pY29uX3dyYXBwZXInKS5hZGRDbGFzcygnbWVudV9hY3RpdmUnKTtcclxuXHJcbiAgICAvLyBGT0NVUyBJTiBTRUFSQ0ggQk9YXHJcbiAgICB2YXIgaW5wdXQgPSAkKFwiLm1zLXNyY2gtc2IgaW5wdXRcIik7XHJcbiAgICBpbnB1dC5mb2N1cygpO1xyXG5cclxuICAgIC8vIFNIT1cgQU5EIEhJREUgTUVOVS1JVEVNXHJcbiAgICAkKCdpbnB1dC5tZW51LWJ0bicpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgJCgnYm9keScpLmNsaWNrKGZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgICAgICAgaWYgKCEkKGV2ZW50LnRhcmdldCkuaXMoJ2xhYmVsJykgJiYgISQoZXZlbnQudGFyZ2V0KS5pcygnaW5wdXQnKSl7XHJcbiAgICAgICAgICAgICAgICAkKCdpbnB1dC5tZW51LWJ0bicpLm5vdCh0aGlzKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgJCgnLm1haW4tbWVudScpLmZpbmQoJ2knKS5hdHRyKCBcImNsYXNzXCIsIFwiZmEgZmEtY2hldnJvbi1kb3duXCIgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgkKGV2ZW50LnRhcmdldCkuaXMoJ2xhYmVsJykgJiYgJChldmVudC50YXJnZXQpLmlzKCdpbnB1dCcpKXtcclxuICAgICAgICAgICAgICAgICQoJ2lucHV0Lm1lbnUtYnRuJykubm90KHRoaXMpLnByb3AoJ2NoZWNrZWQnLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICQoJy5tYWluLW1lbnUnKS5maW5kKCdpJykuYXR0ciggXCJjbGFzc1wiLCBcImZhIGZhLWNoZXZyb24tdXBcIiApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmKCQodGhpcykucHJvcChcImNoZWNrZWRcIikpe1xyXG4gICAgICAgICAgICAkKHRoaXMpLnNpYmxpbmdzKCdhJykuZmluZCgnaScpLmF0dHIoIFwiY2xhc3NcIiwgXCJmYSBmYS1jaGV2cm9uLXVwXCIgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgJCgnLm1haW4tbWVudScpLmZpbmQoJ2knKS5hdHRyKCBcImNsYXNzXCIsIFwiZmEgZmEtY2hldnJvbi1kb3duXCIgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVE8gQUxMT1cgT05MWSBPTkUgSVRFTSBUTyBCRSBDTElDS0VELlxyXG4gICAgICAgICQoJ2lucHV0Lm1lbnUtYnRuJykubm90KHRoaXMpLnByb3AoJ2NoZWNrZWQnLCBmYWxzZSk7XHJcbiAgICAgICAgJCgnI3NlYXJjaC10b2dnbGUtYnRuJykubm90KHRoaXMpLnByb3AoJ2NoZWNrZWQnLCBmYWxzZSk7XHJcbiAgICAgICAgJCgnI3NlYXJjaC1wcm9mZXNzaW9uLXRvZ2dsZS1idG4nKS5ub3QodGhpcykucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgJCgnLnNlYXJjaF9pY29uX3dyYXBwZXInKS5yZW1vdmVDbGFzcygnbWVudV9hY3RpdmUnKTtcclxuICAgICAgICAkKCcuc2VhcmNoX3Byb2Zlc3Npb24nKS5yZW1vdmVDbGFzcygnbWVudV9hY3RpdmUnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEhJREUgSUNPTlMgRE9XTiBJTiBNRU5VLUlURU1cclxuICAgICQoJy5zZWFyY2gtYnRuJykuY2xpY2soZnVuY3Rpb24oKXtcclxuICAgICAgICAkKCdpbnB1dC5tZW51LWJ0bicpLm5vdCh0aGlzKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpO1xyXG4gICAgICAgICQoJy5tYWluLW1lbnUnKS5maW5kKCdpJykuYXR0ciggXCJjbGFzc1wiLCBcImZhIGZhLWNoZXZyb24tZG93blwiICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBTSE9XIEFORCBISURFIFNFQVJDSCBQUk9GRVNTSU9OXHJcbiAgICAkKHdpbmRvdykuY2xpY2soZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBpZiAoISQoZS50YXJnZXQpLmhhc0NsYXNzKFwic2VhcmNoLWJ0blwiKSAmJiAkKGUudGFyZ2V0KS5wYXJlbnRzKFwiI2V4dGVuZGVkX3NlYXJjaF9wcm9mZXNzaW9uXCIpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAkKCcjc2VhcmNoLXByb2Zlc3Npb24tdG9nZ2xlLWJ0bicpLm5vdCh0aGlzKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpO1xyXG4gICAgICAgICAgICAkKCcuc2VhcmNoX3Byb2Zlc3Npb24nKS5yZW1vdmVDbGFzcygnbWVudV9hY3RpdmUnKTsgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCQoJyNzZWFyY2gtcHJvZmVzc2lvbi10b2dnbGUtYnRuJykuaXMoJzpjaGVja2VkJykpe1xyXG4gICAgICAgICAgICAkKCcjc2VhcmNoLXByb2Zlc3Npb24tdG9nZ2xlLWJ0bicpLm5vdCh0aGlzKS5wcm9wKCdjaGVja2VkJywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICQoJyNzZWFyY2gtdG9nZ2xlLWJ0bicpLm5vdCh0aGlzKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpO1xyXG4gICAgICAgICAgICAkKCcubWFpbi1tZW51JykuZmluZCgnaScpLmF0dHIoIFwiY2xhc3NcIiwgXCJmYSBmYS1jaGV2cm9uLWRvd25cIiApOyBcclxuICAgICAgICAgICAgJCgnaW5wdXQubWVudS1idG4nKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpOyBcclxuICAgICAgICAgICAgJCgnLnNlYXJjaF9pY29uX3dyYXBwZXInKS5yZW1vdmVDbGFzcygnbWVudV9hY3RpdmUnKTtcclxuICAgICAgICAgICAgJCgnLnNlYXJjaF9wcm9mZXNzaW9uJykuYWRkQ2xhc3MoJ21lbnVfYWN0aXZlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn0gXHJcblxyXG4vLyBJRiBOT1QgU0VBUkNILkFTUFgsIFNFQVJDSCBCT1ggV0lMTCBCT1RIIFNIT1cgQU5EIEhJREUgV0hFTiBDTElDS0VELCBCVVQgTk9UIEJFIElOIEZPQ1VTIFxyXG4vLyBNRU5VLUlURU0gQU5EIFNFQVJDSC1QUk9GRVNTSU9OIFdJTEwgQk9USCBTSE9XIEFORCBISURFIFdIRU4gQ0xJQ0tFRFxyXG5lbHNlIHtcclxuXHJcbiAgICAvLyBTSE9XIEFORCBISURFIE1FTlUtSVRFTVxyXG4gICAgJCgnaW5wdXQubWVudS1idG4nKS5vbignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICQoJ2h0bWwgYm9keScpLmNsaWNrKGZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgICAgICAgaWYgKCEkKGV2ZW50LnRhcmdldCkuaXMoJ2xhYmVsJykgJiYgISQoZXZlbnQudGFyZ2V0KS5pcygnaW5wdXQnKSl7XHJcbiAgICAgICAgICAgICAgICAkKCdpbnB1dC5tZW51LWJ0bicpLm5vdCh0aGlzKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgJCgnLm1haW4tbWVudScpLmZpbmQoJ2knKS5hdHRyKCBcImNsYXNzXCIsIFwiZmEgZmEtY2hldnJvbi1kb3duXCIgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgkKGV2ZW50LnRhcmdldCkuaXMoJ2xhYmVsJykgJiYgJChldmVudC50YXJnZXQpLmlzKCdpbnB1dCcpKXtcclxuICAgICAgICAgICAgICAgICQoJ2lucHV0Lm1lbnUtYnRuJykubm90KHRoaXMpLnByb3AoJ2NoZWNrZWQnLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICQoJy5tYWluLW1lbnUnKS5maW5kKCdpJykuYXR0ciggXCJjbGFzc1wiLCBcImZhIGZhLWNoZXZyb24tdXBcIiApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmKCQodGhpcykucHJvcChcImNoZWNrZWRcIikpe1xyXG4gICAgICAgICAgICAkKHRoaXMpLnNpYmxpbmdzKCdhJykuZmluZCgnaScpLmF0dHIoIFwiY2xhc3NcIiwgXCJmYSBmYS1jaGV2cm9uLXVwXCIgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICQoJy5tYWluLW1lbnUnKS5maW5kKCdpJykuYXR0ciggXCJjbGFzc1wiLCBcImZhIGZhLWNoZXZyb24tZG93blwiICk7IFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9UTyBBTExPVyBPTkxZIE9ORSBJVEVNIFRPIEJFIENMSUNLRUQuXHJcbiAgICAgICAgJCgnaW5wdXQubWVudS1idG4nKS5ub3QodGhpcykucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcclxuICAgICAgICAkKCcjc2VhcmNoLXRvZ2dsZS1idG4nKS5ub3QodGhpcykucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcclxuICAgICAgICAkKCcjc2VhcmNoLXByb2Zlc3Npb24tdG9nZ2xlLWJ0bicpLm5vdCh0aGlzKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpO1xyXG4gICAgICAgICQoJy5zZWFyY2hfaWNvbl93cmFwcGVyJykucmVtb3ZlQ2xhc3MoJ21lbnVfYWN0aXZlJyk7XHJcbiAgICAgICAgJCgnLnNlYXJjaF9wcm9mZXNzaW9uJykucmVtb3ZlQ2xhc3MoJ21lbnVfYWN0aXZlJyk7XHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgLy8gU0hPVyBBTkQgSElERSBTRUFSQ0ggQk9YXHJcbiAgICAkKHdpbmRvdykuY2xpY2soZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBpZighJChlLnRhcmdldCkuaGFzQ2xhc3MoXCJzZWFyY2gtYnRuXCIpICYmICQoZS50YXJnZXQpLnBhcmVudHMoXCIjZXh0ZW5kZWRfc2VhcmNoXCIpLmxlbmd0aCA9PT0gMCAmJiAhJChcIiNTZWFyY2hCb3hcIikuYXR0cihcInN1Z2dlc3Rpb25fY2xpY2tlZFwiKSl7XHJcbiAgICAgICAgICAgICQoJyNzZWFyY2gtdG9nZ2xlLWJ0bicpLm5vdCh0aGlzKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpOyAgICAgICBcclxuICAgICAgICAgICAgJCgnLnNlYXJjaF9pY29uX3dyYXBwZXInKS5yZW1vdmVDbGFzcygnbWVudV9hY3RpdmUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJCgnI3NlYXJjaC10b2dnbGUtYnRuJykuaXMoJzpjaGVja2VkJykpe1xyXG4gICAgICAgICAgICAkKCcjc2VhcmNoLXRvZ2dsZS1idG4nKS5ub3QodGhpcykucHJvcCgnY2hlY2tlZCcsIHRydWUpO1xyXG4gICAgICAgICAgICAkKCdpbnB1dC5tZW51LWJ0bicpLnByb3AoJ2NoZWNrZWQnLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICQoJy5tYWluLW1lbnUnKS5maW5kKCdpJykuYXR0ciggXCJjbGFzc1wiLCBcImZhIGZhLWNoZXZyb24tZG93blwiICk7IFxyXG4gICAgICAgICAgICAkKCcuc2VhcmNoX2ljb25fd3JhcHBlcicpLmFkZENsYXNzKCdtZW51X2FjdGl2ZScpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLyp2YXIgaW5wdXQgPSAkKFwiLm1zLXNyY2gtc2IgaW5wdXRcIikuZmlyc3QoKTtcclxuICAgICAgICAgICAgaW5wdXQuZm9jdXMoKTsqL1xyXG5cclxuICAgICAgICAgICAgdmFyIGlucHV0ID0gJChcIiNleHRlbmRlZF9zZWFyY2hcIikuZmluZChcImlucHV0XCIpO1xyXG4gICAgICAgICAgICBpbnB1dC5mb2N1cygpO1xyXG5cclxuICAgICAgICB9ICAgXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBTSE9XIEFORCBISURFIFNFQVJDSCBQUk9GRVNTSU9OXHJcbiAgICAkKHdpbmRvdykuY2xpY2soZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBpZiAoISQoZS50YXJnZXQpLmhhc0NsYXNzKFwic2VhcmNoLWJ0blwiKSAmJiAkKGUudGFyZ2V0KS5wYXJlbnRzKFwiI2V4dGVuZGVkX3NlYXJjaF9wcm9mZXNzaW9uXCIpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAkKCcjc2VhcmNoLXByb2Zlc3Npb24tdG9nZ2xlLWJ0bicpLm5vdCh0aGlzKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpO1xyXG4gICAgICAgICAgICAkKCcuc2VhcmNoX3Byb2Zlc3Npb24nKS5yZW1vdmVDbGFzcygnbWVudV9hY3RpdmUnKTsgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGVsc2UgaWYgKCQoJyNzZWFyY2gtcHJvZmVzc2lvbi10b2dnbGUtYnRuJykuaXMoJzpjaGVja2VkJykpe1xyXG4gICAgICAgICAgICAkKCcjc2VhcmNoLXByb2Zlc3Npb24tdG9nZ2xlLWJ0bicpLm5vdCh0aGlzKS5wcm9wKCdjaGVja2VkJywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICQoJyNzZWFyY2gtdG9nZ2xlLWJ0bicpLm5vdCh0aGlzKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpOyBcclxuICAgICAgICAgICAgJCgnaW5wdXQubWVudS1idG4nKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpO1xyXG4gICAgICAgICAgICAkKCcubWFpbi1tZW51JykuZmluZCgnaScpLmF0dHIoIFwiY2xhc3NcIiwgXCJmYSBmYS1jaGV2cm9uLWRvd25cIiApOyBcclxuICAgICAgICAgICAgJCgnLnNlYXJjaF9pY29uX3dyYXBwZXInKS5yZW1vdmVDbGFzcygnbWVudV9hY3RpdmUnKTtcclxuICAgICAgICAgICAgJCgnLnNlYXJjaF9wcm9mZXNzaW9uJykuYWRkQ2xhc3MoJ21lbnVfYWN0aXZlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiVkNtRXN3XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbWFpbk1lbnUuanNcIixcIi9cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5mdW5jdGlvbiBzaG93TmV3c2xldHRlckRpYWxvZyhkaWFsb2dVcmwpIHtcclxuICAgIHZhciBkaWFsb2cgPSB7XHJcbiAgICAgICAgdXJsOiBkaWFsb2dVcmwsXHJcbiAgICAgICAgdGl0bGU6ICdUaWxmw7hqIHRpbCBueWhlZHNicmV2JyxcclxuICAgICAgICBhbGxvd01heGltaXplOiB0cnVlLFxyXG4gICAgICAgIHNob3dDbG9zZTogdHJ1ZSxcclxuICAgICAgICB3aWR0aDogNDIwLFxyXG4gICAgICAgIGhlaWdodDogNTgwLFxyXG4gICAgICAgIGRpYWxvZ1JldHVyblZhbHVlQ2FsbGJhY2s6IGZ1bmN0aW9uIChkaWFsb2dSZXN1bHQpIHtcclxuICAgICAgICAgICAgaWYgKGRpYWxvZ1Jlc3VsdCA9PSBTUC5VSS5EaWFsb2dSZXN1bHQuT0spIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGF0dXNPa0lkO1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzT2tJZCA9IFNQLlVJLlN0YXR1cy5hZGRTdGF0dXMoXCJOeWhlZHNicmV2OlwiLCBcIlNpZGVuIGVyIHRpbGbDuGpldCB0aWwgdmFsZ3RlIGVtbmUocilcIik7XHJcbiAgICAgICAgICAgICAgICBTUC5VSS5TdGF0dXMuc2V0U3RhdHVzUHJpQ29sb3Ioc3RhdHVzT2tJZCwgXCJncmVlblwiKTtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBTUC5VSS5TdGF0dXMucmVtb3ZlU3RhdHVzKHN0YXR1c09rSWQpOyB9LCA1MDAwKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGF0dXNDYW5jZWxJZDtcclxuICAgICAgICAgICAgICAgIHN0YXR1c0NhbmNlbElkID0gU1AuVUkuU3RhdHVzLmFkZFN0YXR1cyhcIk55aGVkc2JyZXY6XCIsIFwiU2lkZW4gYmxldiBpa2tlIHRpbGbDuGpldCBkYSBldCBlbGxlciBmbGVyZSBlbW5lciBpa2tlIGJsZXYgdmFsZ3RcIik7XHJcbiAgICAgICAgICAgICAgICBTUC5VSS5TdGF0dXMuc2V0U3RhdHVzUHJpQ29sb3Ioc3RhdHVzQ2FuY2VsSWQsIFwieWVsbG93XCIpO1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IFNQLlVJLlN0YXR1cy5yZW1vdmVTdGF0dXMoc3RhdHVzQ2FuY2VsSWQpOyB9LCA1MDAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgU1AuVUkuTW9kYWxEaWFsb2cuc2hvd01vZGFsRGlhbG9nKGRpYWxvZyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNob3dTZW5kTmV3c0xldHRlckRpYWxvZyhkaWFsb2dVcmwpIHtcclxuICAgIHZhciBkaWFsb2cgPSB7XHJcbiAgICAgICAgdXJsOiBkaWFsb2dVcmwsXHJcbiAgICAgICAgdGl0bGU6ICdTZW5kIG55aGVkc2JyZXYnLFxyXG4gICAgICAgIGFsbG93TWF4aW1pemU6IHRydWUsXHJcbiAgICAgICAgc2hvd0Nsb3NlOiB0cnVlLFxyXG4gICAgICAgIHdpZHRoOiA0NjAsXHJcbiAgICAgICAgaGVpZ2h0OiAyNjAsXHJcbiAgICAgICAgZGlhbG9nUmV0dXJuVmFsdWVDYWxsYmFjazogZnVuY3Rpb24gKGRpYWxvZ1Jlc3VsdCkge1xyXG4gICAgICAgICAgICBpZiAoZGlhbG9nUmVzdWx0ID09IFNQLlVJLkRpYWxvZ1Jlc3VsdC5PSykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1c09rSWQ7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXNPa0lkID0gU1AuVUkuU3RhdHVzLmFkZFN0YXR1cyhcIk55aGVkc2JyZXY6XCIsIFwiRXIgdW5kZXIgYWZzZW5kZWxzZS4uLlwiKTtcclxuICAgICAgICAgICAgICAgIFNQLlVJLlN0YXR1cy5zZXRTdGF0dXNQcmlDb2xvcihzdGF0dXNPa0lkLCBcImdyZWVuXCIpO1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IFNQLlVJLlN0YXR1cy5yZW1vdmVTdGF0dXMoc3RhdHVzT2tJZCk7IH0sIDUwMDApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1c0NhbmNlbElkO1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzQ2FuY2VsSWQgPSBTUC5VSS5TdGF0dXMuYWRkU3RhdHVzKFwiTnloZWRzYnJldjpcIiwgXCJCbGV2IGlra2UgYWZzZW5kdCBkYSB2aW5kdWV0IGJsZXYgbHVra2V0XCIpO1xyXG4gICAgICAgICAgICAgICAgU1AuVUkuU3RhdHVzLnNldFN0YXR1c1ByaUNvbG9yKHN0YXR1c0NhbmNlbElkLCBcInllbGxvd1wiKTtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBTUC5VSS5TdGF0dXMucmVtb3ZlU3RhdHVzKHN0YXR1c0NhbmNlbElkKTsgfSwgNTAwMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIFNQLlVJLk1vZGFsRGlhbG9nLnNob3dNb2RhbERpYWxvZyhkaWFsb2cpO1xyXG59XHJcblxyXG4oZnVuY3Rpb24od2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKXtcclxuICAgIHdpbmRvdy5zaG93TmV3c2xldHRlckRpYWxvZyA9IHNob3dOZXdzbGV0dGVyRGlhbG9nO1xyXG4gICAgd2luZG93LnNob3dTZW5kTmV3c0xldHRlckRpYWxvZyA9IHNob3dTZW5kTmV3c0xldHRlckRpYWxvZztcclxufSkod2luZG93LCBkb2N1bWVudCk7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcIlZDbUVzd1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL25ld3NMZXR0ZXJEaWFsb2cuanNcIixcIi9cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4oZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGJlZm9yZVByaW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICQoXCJkaXYsYSxoMyxoMixoMSxwLHNwYW4sdGltZVwiKS5jc3MoXCJmb250LWZhbWlseVwiLCBcIlNlZ29lIFVJXCIpO1xyXG4gICAgICAgIC8vRm9sZCBldmVyeXRoaW5nIG91dFxyXG4gICAgICAgICQoXCIuZmFrZS1mb2xkXCIpLnNob3coKTtcclxuICAgICAgICAkKFwiLm1zLXJ0ZUVsZW1lbnQtRm9sZEhlYWRpbmdcIikuY3NzKFwiYmFja2dyb3VuZC1pbWFnZVwiLCBcInVybCgvX2xheW91dHMvMTUvTmV0Y29tcGFueS5GVlMwMDAxL2ltYWdlcy9taW51c2ljb24ucG5nKVwiKTtcclxuICAgIH07XHJcbiAgICB2YXIgYWZ0ZXJQcmludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAkKFwiLmZha2UtZm9sZFwiKS5oaWRlKCk7XHJcbiAgICAgICAgJChcIi5tcy1ydGVFbGVtZW50LUZvbGRIZWFkaW5nXCIpLmNzcyhcImJhY2tncm91bmQtaW1hZ2VcIiwgXCJ1cmwoL19sYXlvdXRzLzE1L05ldGNvbXBhbnkuRlZTMDAwMS9pbWFnZXMvcGx1c2ljb24ucG5nKVwiKTtcclxuICAgIH07XHJcblxyXG4gICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKSB7XHJcbiAgICAgICAgdmFyIG1lZGlhUXVlcnlMaXN0ID0gd2luZG93Lm1hdGNoTWVkaWEoJ3ByaW50Jyk7XHJcbiAgICAgICAgbWVkaWFRdWVyeUxpc3QuYWRkTGlzdGVuZXIoZnVuY3Rpb24gKG1xbCkge1xyXG4gICAgICAgICAgICBpZiAobXFsLm1hdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgIGJlZm9yZVByaW50KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhZnRlclByaW50KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB3aW5kb3cub25iZWZvcmVwcmludCA9IGJlZm9yZVByaW50O1xyXG4gICAgd2luZG93Lm9uYWZ0ZXJwcmludCA9IGFmdGVyUHJpbnQ7XHJcbn0oKSk7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcIlZDbUVzd1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL3ByaW50RnVuY3Rpb24uanNcIixcIi9cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLyoqRk9SIE5FVyBTUDIwMTMgQ09ERSoqLy9cclxuLy9tbWNAbmV0Y29tcGFueS5jb20gLSBUb2dnbGUgU2hhcmUtYnRuIC0gMjAtMTEtMjAxNFxyXG5cclxuLy9TZXJ2aWNlIG1lbnVcclxuJChcIi5zaGFyZVwiKS5jbGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAkKFwiLnNoYXJlX2J0bnNcIikuc2xpZGVUb2dnbGUoJ3Nob3cnKTtcclxufSk7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcIlZDbUVzd1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL3NoYXJlRnVuY3Rpb24uanNcIixcIi9cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cclxuKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCl7XHJcblxyXG4gICAgd2luZG93LlNoYXJlUG9pbnRVdGlsaXRpZXMgPSB3aW5kb3cuU2hhcmVQb2ludFV0aWxpdGllcyB8fCB7fTtcclxuXHJcbiAgICAvKlxyXG4gICAgd2luZG93LlNoYXJlUG9pbnRVdGlsaXRpZXMuc2hvd0RpYWxvZyA9IGZ1bmN0aW9uICh1cmwsIHRpdGxlLCBoZWlnaHQsIHdpZHRoKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHVybDogdXJsLCAvLysgXCImSXNEbGc9MVwiLFxyXG4gICAgICAgICAgICB0aXRsZTogdGl0bGUsXHJcbiAgICAgICAgICAgIGFsbG93TWF4aW1pemU6IHRydWUsXHJcbiAgICAgICAgICAgIHNob3dDbG9zZTogdHJ1ZSxcclxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgICAgZGlhbG9nUmV0dXJuVmFsdWVDYWxsYmFjazogZGlhbG9nQ2FsbGJhY2tcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNQLlNPRC5leGVjdXRlKCdzcC51aS5kaWFsb2cuanMnLCAnU1AuVUkuTW9kYWxEaWFsb2cuc2hvd01vZGFsRGlhbG9nJywgb3B0aW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBkaWFsb2dDYWxsYmFjayhyZXN1bHQsIHJlc3BvbnNlKSB7XHJcbiAgICAgICAgc3dpdGNoIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgY2FzZSBTUC5VSS5EaWFsb2dSZXN1bHQuY2FuY2VsOlxyXG4gICAgICAgICAgICAgICAgLy9kbyBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBTUC5VSS5EaWFsb2dSZXN1bHQuaW52YWxpZDpcclxuICAgICAgICAgICAgICAgIC8vZG8gbm90aGluZ1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU1AuVUkuRGlhbG9nUmVzdWx0Lm9rOlxyXG4gICAgICAgICAgICAgICAgdmFyIG5vdGUgPSBTUC5VSS5Ob3RpZnkuYWRkTm90aWZpY2F0aW9uKHJlc3BvbnNlLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgKi9cclxuXHJcblxyXG4gICAgLy9mdW5jdGlvbiB0byBvcGVuIHBhZ2VzIGluIGEgZGlhbG9nXHJcbiAgICBmdW5jdGlvbiBvcGVuSW5EaWFsb2coZGxnV2lkdGgsIGRsZ0hlaWdodCwgZGxnQWxsb3dNYXhpbWl6ZSxkbGdTaG93Q2xvc2UsbmVlZENhbGxiYWNrRnVuY3Rpb24sIHBhZ2VVcmwpIFxyXG4gICAgeyAgICBcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHsgdXJsOiBwYWdlVXJsLCB3aWR0aDogZGxnV2lkdGgsIGhlaWdodDogZGxnSGVpZ2h0LCBhbGxvd01heGltaXplOiBkbGdBbGxvd01heGltaXplLFxyXG4gICAgICAgICAgICBzaG93Q2xvc2U6IGRsZ1Nob3dDbG9zZSAgICAgXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIGlmKG5lZWRDYWxsYmFja0Z1bmN0aW9uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5kaWFsb2dSZXR1cm5WYWx1ZUNhbGxiYWNrID0gRnVuY3Rpb24uY3JlYXRlRGVsZWdhdGUobnVsbCwgQ2xvc2VEaWFsb2dDYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFNQLlNPRC5leGVjdXRlKCdzcC51aS5kaWFsb2cuanMnLCAnU1AuVUkuTW9kYWxEaWFsb2cuc2hvd01vZGFsRGlhbG9nJywgb3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gQ2xvc2VEaWFsb2dDYWxsYmFjayhkaWFsb2dSZXN1bHQsIHJldHVyblZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIC8vaWYgdXNlciBjbGljayBvbiBPSyBvciBTYXZlXHJcbiAgICAgICAgIGlmKGRpYWxvZ1Jlc3VsdCA9PSBTUC5VSS5EaWFsb2dSZXN1bHQuT0spXHJcbiAgICAgICAgIHsgIC8vIHJlZnJlc2ggcGFyZW50IHBhZ2VcclxuICAgICAgICAgICAgU1AuU09ELmV4ZWN1dGUoJ3NwLnVpLmRpYWxvZy5qcycsICdTUC5VSS5Nb2RhbERpYWxvZy5SZWZyZXNoUGFnZScsIFNQLlVJLkRpYWxvZ1Jlc3VsdC5PSyk7ICAgICAgICAgIFxyXG4gICAgICAgICB9XHJcbiAgICAgICAgIC8vIGlmIHVzZXIgY2xpY2sgb24gQ2xvc2Ugb3IgQ2FuY2VsXHJcbiAgICAgICAgIGVsc2UgaWYoZGlhbG9nUmVzdWx0ID09IFNQLlVJLkRpYWxvZ1Jlc3VsdC5jYW5jZWwpXHJcbiAgICAgICAgIHsgIC8vIERvIE5vdGhpbmcgb3IgYWRkIGFueSBsb2dpYyB5b3Ugd2FudCBcclxuICAgICAgICAgfVxyXG4gICAgICAgICBlbHNlXHJcbiAgICAgICAgIHsvL2FsZXJ0KFwiZWxzZSBcIiArIGRpYWxvZ1Jlc3VsdCk7XHJcbiAgICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB3aW5kb3cuU2hhcmVQb2ludFV0aWxpdGllcy5vcGVuSW5EaWFsb2cgPSBvcGVuSW5EaWFsb2c7XHJcblxyXG59KSh3aW5kb3csIGRvY3VtZW50KTtcclxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIlZDbUVzd1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL3NoYXJlUG9pbnRVdGlsaXRpZXMuanNcIixcIi9cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vL1RPIE1BS0UgVEhJUyBSRU5ERVIgT04gV0lORE9XIExPQUQgTk9UIE9OIERPQ1VNRU5UIFJFQURZLihHbG9iYWwgRnVuY3Rpb24pXHJcbihmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpe1xyXG4gIFx0d2luZG93LnRvZ2dsZVNob3dCdXR0b24gPSBmdW5jdGlvbihzaG93QnV0dG9uKXtcclxuXHQgIFx0dmFyIHNlbGVjdG9yID0gJChzaG93QnV0dG9uKTtcclxuXHRcdHNlbGVjdG9yLnBhcmVudCgpLnNpYmxpbmdzKCkuZmluZCgnLmhpZGRlbl9yZWZpbmVyX2xpc3QnKS5zbGlkZVRvZ2dsZSgnc2xvdycpO1x0XHRcdFx0ICAgICAgICBcclxuXHJcblx0XHR2YXIgbG9jYWxpemVkU2hvd01vcmVUZXh0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgPT0gJ2RhLURLJyA/IFwiVmlzIGZsZXJlXCIgOiBcIlNob3cgbW9yZVwiO1xyXG5cdFx0dmFyIGxvY2FsaXplZFNob3dMZXNzVGV4dCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nID09ICdkYS1ESycgPyBcIlZpcyBmw6ZycmVcIiA6IFwiU2hvdyBsZXNzXCI7XHJcblxyXG5cdFx0dmFyIHNob3dCdXR0b25UZXh0ID0gKHNlbGVjdG9yLmh0bWwoKSA9PSBsb2NhbGl6ZWRTaG93TGVzc1RleHQgPyBsb2NhbGl6ZWRTaG93TW9yZVRleHQgOiBsb2NhbGl6ZWRTaG93TGVzc1RleHQpO1xyXG5cdFx0c2VsZWN0b3IuaHRtbChzaG93QnV0dG9uVGV4dCk7XHJcblx0fTtcclxufSkod2luZG93LCBkb2N1bWVudCk7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcIlZDbUVzd1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL3Nob3dBbGxSZWZpbmVyLmpzXCIsXCIvXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8vLy8vLy8vISEhISEhISBNYWtlIGNvbW1lbnRzIGFuZCBtYWtlIGZ1bmN0aW9ucyByZXVzYWJlbCBhcyB2YXJpYWJsZS8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyEhISEhIVxyXG5cclxuLy8qKkZPUiBORVcgU1AyMDEzIENPREUqKi8vXHJcbi8vbW1jQG5ldGNvbXBhbnkuY29tIC0gVG9nZ2xlRnVuY3Rpb25zIC0gMTktMTEtMjAxNFxyXG5cclxuLy9TZXJ2aWNlIG1lbnVcclxuLy8gRk9SIFRPT0dMRSBBUlJPVyBVUCBBTkQgRE9XTiBJTlNJREUgQ0lSQ0xFIFxyXG4kKFwiLnRvZ2dsZVwiKS5jbGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAkKFwiLnRvZ2dsZV9hcnJvd1wiKS50b2dnbGVDbGFzcygnZmEtYW5nbGUtZG93biBmYS1hbmdsZS11cCcpO1xyXG59KTtcclxuXHJcbi8vVE9HR0xFIENIRVZST05TICghISEhISEhISEhTUFZQkUgUkVNT1ZFIFRISVMhISEhISEhISEhISEhKSBcclxuJChcIi50b2dnbGVfY2hldnJvblwiKS5jbGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAkKHRoaXMpLmZpbmQoJ2knKS50b2dnbGVDbGFzcygnZmEtY2hldnJvbi1kb3duIGZhLWNoZXZyb24tdXAnKTtcclxufSk7XHJcblxyXG4vL1RPR0dMRSArIC0gaWNvbnMgLSBJUyBVU0VEIE9OIEFMTCBHVUlERSBST09MVVAgISBcclxuLyokKFwiLnRvZ2dsZV9idG5cIikuY2xpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgJCh0aGlzKS5maW5kKCdpJykudG9nZ2xlQ2xhc3MoJ3BsdXNfaWNvbiBtaW51c19pY29uJyk7XHJcbiAgICAkKHRoaXMpLmZpbmQoXCIuUGlja2VyU2hvd0FsbFwiKS50b2dnbGVDbGFzcyhcIlBpY2tlckhpZGVTaG93LU5vbmVcIik7XHJcbn0pOyovXHJcblxyXG4vLyBORVcgVE9HR0xFICsgLSBpY29ucyBBTkQgU2hvd0FsbCBIaWRlQWxsXHJcbiQoXCIudG9nZ2xlX2J0blwiKS5maW5kKCdpbnB1dCcpLmNoYW5nZShmdW5jdGlvbigpe1xyXG5cdCQodGhpcykucGFyZW50KCkuZmluZCgnaScpLmZpcnN0KCkudG9nZ2xlQ2xhc3MoJ3BsdXNfaWNvbiBtaW51c19pY29uJyk7XHJcbiAgICAkKHRoaXMpLnBhcmVudCgpLmZpbmQoXCIuUGlja2VyU2hvd0FsbFwiKS50b2dnbGVDbGFzcyhcIlBpY2tlckhpZGVTaG93LU5vbmVcIik7XHJcbn0pO1xyXG5cclxuJChcIi5QaWNrZXJTaG93LCAucGx1c19taW51c1wiKS5jbGljayhmdW5jdGlvbigpIHtcclxuICAgICQodGhpcykuY2xvc2VzdCgnLnRvZ2dsZV9idG4nKS5maW5kKCdpbnB1dCcpLnRyaWdnZXIoJ2NsaWNrJyk7XHJcbn0pO1xyXG5cclxuLy9UT0dHTEUgKyAtIGljb25zIC0gSVMgVVNFRCBPTiBBTEwgR1VJREUgUk9PTFVQICEgVE9ETzpSRU1PVkUgVVNBR0UgT0YgVEhJUyBDTEFTIEFORCBDSEFOR0UgVE8gU0FNRSBBUyBBQk9WRVxyXG4kKFwiLnRlbXBsYXRlX3RvZ2dsZV9idG5cIikuY2xpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgJCh0aGlzKS5maW5kKCdpJykudG9nZ2xlQ2xhc3MoJ3BsdXNfaWNvbiBtaW51c19pY29uJyk7XHJcbn0pO1xyXG5cclxuLy9GT1IgU1REIFNIQVJFUE9JTlQgV0VCUEFSVFxyXG5pZigkKFwiLnRvcF9yZWZpbmVyX2NvbnRhaW5lciBpbnB1dDpjaGVja2VkXCIpKXtcclxuICAgICQoXCIudG9wX3JlZmluZXJfY29udGFpbmVyIGlucHV0OmNoZWNrZWRcIikubmV4dCgnbGFiZWwnKS5hZGRDbGFzcygnYWN0aXZlX3JlZmluZXInKTtcclxufVxyXG5cclxuLy8gTkxIIDIwMTUtMTEtMDMgOiBBZGQgaWNvbnMgZm9yIGV4dGVybmFsIHVybHMgb25seVxyXG4kKFwiLnRleHRyb3RhdG9yX21hbmNoZXRcIikuZmluZChcImFcIikuZWFjaChmdW5jdGlvbiggaW5kZXggKSB7XHJcbiAgdmFyIGhyZWYgPSAkKHRoaXMpLmF0dHIoXCJocmVmXCIpO1xyXG4gIGlmIChocmVmICYmIGhyZWYuaW5kZXhPZignaHR0cCcpPT09MCkge1xyXG4gIFx0ICQodGhpcykuYWRkQ2xhc3MoXCJleHRlcm5hbC11cmxcIik7XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gIFx0ICQodGhpcykuYWRkQ2xhc3MoXCJpbnRlcm5hbC11cmxcIik7XHRcclxuICB9XHJcbn0pO1xyXG5cclxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIlZDbUVzd1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL3RvZ2dsZUFycm93RnVuY3Rpb24uanNcIixcIi9cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4kKCcudG9vbHRpcCcpLnRvb2x0aXBzdGVyKHtcclxuXHRtdWx0aXBsZTogdHJ1ZSxcclxuXHRwb3NpdGlvbjogJ3RvcCdcclxufSk7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcIlZDbUVzd1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL3Rvb2x0aXAuanNcIixcIi9cIikiXX0=

/* Mobile menu JS start */
$(function () {
    $(".sidenav-nested-toggler").click(function () {
        $(this).next(".sidenav-nested-hidden").toggle();
        $(this).toggleClass("fa-chevron-down fa-chevron-up");
    });
});

/* Search sites stuff */
/*$(window).resize(function () {
    if(window.screen.width > 991){
        $(".refiner_list").addClass("hidden_refiner_list");
    }
    if (window.screen.width >= 991) {
        $(".refiner_list:lt(5)").removeClass("hidden_refiner_list").show(":hidden");
    }
});*/

function openNav() {
    document.getElementById("mySidenav").style.width = "100%";
    //document.getElementById("mySidenav").style.height = "100%";
    document.getElementById("mySidenav").style.position = "absolute";
    document.getElementById("mySidenav").style.display = "block";
    //document.getElementById("main").style.marginLeft = "250px";
    //document.body.style.backgroundColor = "rgba(0,0,0,0.4)";
}

/* Set the width of the side navigation to 0 and the left margin of the page content to 0, and the background color of body to white */
function closeNav() {
    document.getElementById("mySidenav").style.width = "0";
    //document.getElementById("mySidenav").style.height = "0";
    document.getElementById("mySidenav").style.display = "none";
    //document.body.style.backgroundColor = "white";
}
$(document).ready(function () {
    $("#sidenav-list > li").click(function () {
        $(this).find("ul.sidenav-list-nested").toggleClass('hide');
    });
    $(".content_main table, .content_main .ms-rtestate-field img").wrap("<div class='table-wrapper'></div>");
});

